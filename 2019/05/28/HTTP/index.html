<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="1. 概念超文本传输协议（HyperText Transport Protocol），基于TCP/IP的应用层协议，默认端口号是80，基于请求响应模型（一次请求对应一次响应），是无状态的（每次请求是项目独立的）。  1.0版本：每次请求响应都会建立一次HTTP连接 1.1版本：HTTP连接会被复用，一次连接可以传输多次数据  2. Request对象和Response对象 服务器在收到一次请求消息">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP协议">
<meta property="og:url" content="http://yoursite.com/2019/05/28/HTTP/index.html">
<meta property="og:site_name" content="酒徒">
<meta property="og:description" content="1. 概念超文本传输协议（HyperText Transport Protocol），基于TCP/IP的应用层协议，默认端口号是80，基于请求响应模型（一次请求对应一次响应），是无状态的（每次请求是项目独立的）。  1.0版本：每次请求响应都会建立一次HTTP连接 1.1版本：HTTP连接会被复用，一次连接可以传输多次数据  2. Request对象和Response对象 服务器在收到一次请求消息">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-05-28T15:36:06.044Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HTTP协议">
<meta name="twitter:description" content="1. 概念超文本传输协议（HyperText Transport Protocol），基于TCP/IP的应用层协议，默认端口号是80，基于请求响应模型（一次请求对应一次响应），是无状态的（每次请求是项目独立的）。  1.0版本：每次请求响应都会建立一次HTTP连接 1.1版本：HTTP连接会被复用，一次连接可以传输多次数据  2. Request对象和Response对象 服务器在收到一次请求消息">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/05/28/HTTP/">





  <title>HTTP协议 | 酒徒</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">酒徒</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/28/HTTP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="酒徒">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒徒">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HTTP协议</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-05-28T22:42:22+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>超文本传输协议（HyperText Transport Protocol），基于TCP/IP的应用层协议，默认端口号是<strong>80</strong>，基于请求响应模型（一次请求对应一次响应），是无状态的（每次请求是项目独立的）。</p>
<ol>
<li>1.0版本：每次请求响应都会建立一次HTTP连接</li>
<li>1.1版本：HTTP连接会被复用，一次连接可以传输多次数据</li>
</ol>
<h2 id="2-Request对象和Response对象"><a href="#2-Request对象和Response对象" class="headerlink" title="2. Request对象和Response对象"></a>2. Request对象和Response对象</h2><ol>
<li><strong>服务器在收到一次请求消息后做的事情：</strong><ol>
<li>Tomcat服务器根据请求URL的资源路径创建对应的Servlet对象</li>
<li>Tomcat服务器创建Request对象和Response对象，其中在Request对象中封装请求消息数据</li>
<li>Tomcat将Request对象和Response对象传递给service方法，并且通过Servlet对象调用该方法</li>
<li>在该方法中，可以根据Request对象获取请求消息数据，并通过Response对象设置响应消息数据</li>
<li>服务器在给浏览器做出响应之前会从Response对象中得到设置好的响应消息数据</li>
</ol>
</li>
</ol>
<h2 id="3-HTTP请求消息数据格式"><a href="#3-HTTP请求消息数据格式" class="headerlink" title="3. HTTP请求消息数据格式"></a>3. HTTP请求消息数据格式</h2><ol>
<li><p>Request对象的继承体系结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServletRequest -- 接口</span><br><span class="line">	|继承</span><br><span class="line">HttpServletRequest -- 接口</span><br><span class="line">	|实现</span><br><span class="line">RequestFacade -- 实现类</span><br></pre></td></tr></table></figure>
<p>该实现类有Apache编写，<code>org.apache.catalina.connector.RequestFacade</code></p>
</li>
<li><p>请求行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求方法 请求URL 请求协议/版本</span><br></pre></td></tr></table></figure>
<ol>
<li>请求方法：HTTP有7中请求方式，常用的有两种<ol>
<li>GET：<ol>
<li>请求参数在请求行中（在URL后）</li>
<li>请求的URL长度有限制</li>
<li>相对没那么安全</li>
</ol>
</li>
<li>POST：<ol>
<li>请求参数在请求体中</li>
<li>请求URL长度没有限制</li>
<li>相对安全</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>请求头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求头名称：请求头值</span><br></pre></td></tr></table></figure>
<p>常用的请求头：</p>
<ol>
<li>User-Agent：告诉服务器浏览器版本信息<ol>
<li>可以用来解决浏览器版本兼容性问题</li>
</ol>
</li>
<li>Accept：可以接收、解析的信息</li>
<li>Connection：keep-alive，1.1版本、连接复用</li>
<li>Referer：Referer: <a href="http://localhost/login.html，告诉服务器，当前请求是从哪里来的" target="_blank" rel="noopener">http://localhost/login.html，告诉服务器，当前请求是从哪里来的</a><ol>
<li>作用有：防止盗链、统计流量来源数量等</li>
</ol>
</li>
</ol>
</li>
<li><p>请求空行：就是一个空行，用来分隔请求头和请求体</p>
</li>
<li><p>请求体：封装POST请求消息的请求参数的</p>
<ol>
<li>GET方法没有请求体，POST方法的请求体为 name=值</li>
</ol>
</li>
<li><p>一个简单的完整的请求消息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /demo3 HTTP/1.1 -- 请求行</span><br><span class="line">Host: localhost</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 13</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Origin: http://localhost</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3</span><br><span class="line">x-xyst: KHgiNG8mJjdUdnVPSnIxRYrXQyBkSfrS47T_FU7_372biFAU4QMaRw==</span><br><span class="line">Referer: http://localhost/login.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: en-US,en;q=0.9,is;q=0.8,zh;q=0.7,zh-CN;q=0.6,zh-TW;q=0.5,ja;q=0.4,nl;q=0.3</span><br><span class="line">Cookie: Idea-ba272247=a33d6b38-3af8-4b08-b337-f1e8c3cc1311; JSESSIONID=F43308216BD55AAF85AF182BEA04824F</span><br><span class="line">														-- 请求空行</span><br><span class="line">														</span><br><span class="line">username=bobby -- 请求体</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="4-Request对象的功能"><a href="#4-Request对象的功能" class="headerlink" title="4.Request对象的功能"></a>4.Request对象的功能</h2><ol>
<li><p><strong>获取请求消息数据</strong></p>
<ol>
<li><p>获取请求行数据，假如请求行是这个：GET /servlet/demo3?username=aaa HTTP/1.1</p>
<ol>
<li>获取请求方式（GET）：String getMethod()</li>
<li>(*)获取虚拟目录(/servlet)：String getContextPath()，一般用来动态获取虚拟目录，而不是写死。</li>
<li>获取Servlet路径（/demo3）：String getServletPath()</li>
<li>获取get方式的请求参数(username=aaa)：String getQueryString()</li>
<li>(*)获取请求的URI（/servlet/demo3）<ol>
<li>String getRequestURI():          /servlet/demo3</li>
<li>String getRequestURL():         <a href="http://localhost/servlet/demo3" target="_blank" rel="noopener">http://localhost/servlet/demo3</a></li>
</ol>
</li>
<li>获取协议版本(HTTP/1.1)：String getProtocol()</li>
<li>获取客户机的IP地址：String getRemoteAddr()</li>
</ol>
</li>
<li><p>获取请求头数据</p>
<ol>
<li>String getHeader(String name)：根据请求头名称，获取请求头的值</li>
<li>Enumeration&lt; String &gt; getHeaderNames()：获取所有的请求头名称</li>
</ol>
</li>
<li><p>获取请求体的数据</p>
<ol>
<li><p>只有POST方法才有请求体，在请求体中封装了POST请求的请求参数</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>获取流对象</p>
<ol>
<li>BufferReader getReader()：获取字符输入流，只能操作字符数据</li>
<li>ServletInputStream getInputStream()：获取字节输入流，可以操作所有的数据类型</li>
</ol>
</li>
<li><p>从流对象里拿到参数数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">          BufferedReader br = request.getReader();</span><br><span class="line">          String str = null;</span><br><span class="line">          while ((str = br.readLine()) != null) &#123;</span><br><span class="line">              System.out.println(str);// username=bbbb&amp;password=bbbb</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p><strong>其他的功能</strong></p>
<ol>
<li><p>获取请求参数的通用方式(兼容GET和POST)</p>
<ol>
<li>String getParameter(String name) ：根据参数名获取参数值</li>
<li>String[] getParameterValues(String name)：根据参数名获取参数值的数组，针对复选框的情况</li>
<li>Enumeration&lt; String &gt; getParameterNames()：获取所有请求的参数名</li>
<li>Map&lt;String, String[]&gt; getParameterMap()：获取所有参数的map集合</li>
</ol>
<p><strong>注意：</strong>获取请求参数时会可能出现乱码情况，修改编码格式即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(&quot;utf-8&quot;); -- utf-8为输入参数的注册页面格式</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>请求转发：一种在服务器内部的资源跳转方式</p>
<ol>
<li><p>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</p>
</li>
<li><p>RequestDispatcher对象调用forward方法进行转发：forward(ServletRequest request，ServletResponse)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;demo8888888888888888&quot;);</span><br><span class="line">request.getRequestDispatcher(&quot;/requestDemo7&quot;).forward(request,response);</span><br><span class="line"></span><br><span class="line">// 这样不仅可以访问到demo8，还可以访问到demo7，因为在demo8里请求转发到demo7</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求转发的特点：</p>
<ol>
<li>浏览器地址栏的路径不会改变</li>
<li>只能请求转发本服务器内部的资源，不能请求其他资源</li>
<li>转发只是一次请求，不会因为访问了多个资源就是多个请求</li>
</ol>
</li>
</ol>
</li>
<li><p>共享数据：请求转发实际上是两个Servlet之间的通信，可以使用共享数据的方法进行通信，一个Servlet了可以存储数据，另一个Servlet可以读取数据</p>
<ol>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域：值得是一次请求的范围，该范围可以因为请求转发而被扩大，一般用于在发生请求转发的多个资源中进行数据的共享。</li>
<li>方法：<ol>
<li>void setAttribute(String name, Object obj)：存储数据</li>
<li>Object getAttribute(String name)：根据键获取数据</li>
<li>void removeAttribute(String name)：根据键移除数据</li>
</ol>
</li>
</ol>
</li>
<li><p>获取ServletContext</p>
<ol>
<li>方法：servletContext getServletContext()</li>
</ol>
</li>
</ol>
<h2 id="5-HTTP响应消息的数据格式"><a href="#5-HTTP响应消息的数据格式" class="headerlink" title="5. HTTP响应消息的数据格式"></a>5. HTTP响应消息的数据格式</h2><ol>
<li><p><strong>响应行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>组成：协议版本、响应的状态码、响应的状态</p>
<p>状态码对应的状态：</p>
<ol>
<li>1XX：服务器接收到信息，但是没有完成，在等待一段时间后，发送1XX给客户端</li>
<li>2XX：成功，如：200</li>
<li>3XX：重定向，如：302（重定向）、304（访问缓存）</li>
<li>4XX：客户端错误，如：404（访问路径没有对应资源）、405（请求方法没有对应的doGet或者doPost方法）</li>
<li>5XX：服务器内部出现异常，如：500（服务器内部出现异常）</li>
</ol>
</li>
<li><p><strong>响应头</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Length: 101</span><br><span class="line">Date: Thu, 25 Apr 2019 07:43:37 GMT</span><br></pre></td></tr></table></figure>
<p>格式：响应头名称：响应值</p>
<p>常见的响应头：</p>
<ol>
<li>Content-Type：服务器告知客户端本次响应的数据格式以及编码方式</li>
<li>Content-Length：响应体的长度，以字节为单位</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体的数据<ol>
<li>值为 <code>in-line</code>：默认值，在当前页面打开响应体</li>
<li>值为 <code>attachment;filename=xxx</code>：以附件形式打开响应体，一般用于文件下载</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>响应空行</strong></p>
</li>
<li><p><strong>响应体</strong>：真实的传输的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;index.jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    response.jsp</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-Response对象的功能"><a href="#6-Response对象的功能" class="headerlink" title="6. Response对象的功能"></a>6. Response对象的功能</h2><ol>
<li><p><strong>设置响应消息</strong></p>
<ol>
<li>设置响应行：HTTP/1.1 200 OK<ol>
<li>设置状态码：setStatus(int sc)</li>
</ol>
</li>
<li>设置响应头：setHeader(String name, String value)</li>
<li>设置响应体：<ul>
<li>使用步骤：<ol>
<li>获取输出流<ol>
<li>获取字节输出流：ServletOutputStream getOutputStream()</li>
<li>获取字符输出流：PrintWriter getWrite()</li>
</ol>
</li>
<li>使用输出流影数据输出到浏览器</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>Response对象的功能：</strong></p>
<ol>
<li><p><strong>实现重定向</strong>：</p>
<ol>
<li>代码实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(302);</span><br><span class="line">response.setHeader(&quot;location&quot;, &quot;/response/ResponseDemo2&quot;);</span><br><span class="line">/***********或者**************/</span><br><span class="line">response.sendRedirect(&quot;/response/ResponseDemo2&quot;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>重定向和转发的区别</p>
<p>|   重定向（redirect）   |      转发（forward）       |<br>| :——————–: | :————————: |<br>|     地址栏发生变化     |      地址栏不发生变化      |<br>| 可以访问其他站点的资源 | 只能访问本服务器内部的资源 |<br>|    重定向是两次请求    |       转发是一次请求       |</p>
<p><strong>解析：</strong>由于转发是一次请求，因此可以使用Request对象来共享数据，但是重定向是两次请求，因此有两个Request对象，不能通过Request对象共享数据。</p>
</li>
<li><p>路径的写法：</p>
</li>
</ol>
</li>
<li><p><strong>输出数据</strong>：</p>
<ol>
<li><p>服务器输出<strong>字符</strong>到浏览器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取字符输出流之前先设置编码格式为utf-8，避免中文乱码</span><br><span class="line">response.setContentType(&quot;text/html; charset=utf-8&quot;);</span><br><span class="line">PrintWriter writer = response.getWriter();</span><br><span class="line">writer.write(&quot;&lt;h1&gt;我写几个中文吧，hello, i am a response message!&lt;/h1&gt;&quot;);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>2. 服务器输出**字节**浏览器：（一般用来输出图片等信息）

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(&quot;text/html; charset = utf-8&quot;);</span><br><span class="line">ServletOutputStream os = response.getOutputStream();</span><br><span class="line">os.write(&quot;猪八戒&quot;.getBytes());</span><br></pre></td></tr></table></figure>


3. 验证码的小demo

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet(&quot;/checkCodeServlet&quot;)</span><br><span class="line">public class CheckCodeServlet extends HttpServlet &#123;</span><br><span class="line">    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        this.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">        int width  = 100;</span><br><span class="line">        int height = 50;</span><br><span class="line">        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line">        // 填充背景色</span><br><span class="line">        Graphics graphics = image.getGraphics();</span><br><span class="line">        graphics.setColor(Color.pink);</span><br><span class="line">        graphics.fillRect(0, 0, width, height);</span><br><span class="line"></span><br><span class="line">        // 画边框</span><br><span class="line">        graphics.setColor(Color.BLUE);</span><br><span class="line">        graphics.drawRect(0, 0, width - 1, height - 1);</span><br><span class="line"></span><br><span class="line">        // 随机画四个字母</span><br><span class="line">        String str = &quot;ABCDEFGHIJKLMNOPQTSTUVWXYZabcdefghijkilmnopqrstuvwxyz0123456789&quot;;</span><br><span class="line">        Random random = new Random();</span><br><span class="line">        for(int i = 1; i &lt; 5; i++) &#123;</span><br><span class="line"></span><br><span class="line">            int index = random.nextInt(str.length());</span><br><span class="line">            char c = str.charAt(index);</span><br><span class="line">            graphics.drawString(c+&quot;&quot;, i * 20, height / 2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 随机画干扰线</span><br><span class="line">        graphics.setColor(Color.GREEN);</span><br><span class="line">        for(int i = 0; i &lt; 15; i++) &#123;</span><br><span class="line">            int x1 = random.nextInt(width);</span><br><span class="line">            int y1 = random.nextInt(height);</span><br><span class="line">            int x2 = random.nextInt(width);</span><br><span class="line">            int y2 = random.nextInt(height);</span><br><span class="line">            graphics.drawLine(x1, y1, x2, y2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean jpg = ImageIO.write(image, &quot;jpg&quot;, response.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


   **验证码切换**

   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.onload = function () &#123;</span><br><span class="line">        var image = document.getElementById(&quot;checkCode&quot;);</span><br><span class="line">        image.onclick = function () &#123;</span><br><span class="line">            // 由于其实每次都是访问一样的Servlet，因此要加时间戳，欺骗服务器每次请求不一样，这样就可以不访问浏览器的本地缓存</span><br><span class="line">            var date = new Date().getTime();</span><br><span class="line">            image.src = &quot;/response/checkCodeServlet&quot; + &quot;?&quot; + date;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var link = document.getElementById(&quot;change&quot;);</span><br><span class="line">        link.onclick = function () &#123;</span><br><span class="line">            var date = new Date().getTime();</span><br><span class="line">            image.src = &quot;/response/checkCodeServlet&quot; + &quot;?&quot; + date;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</code></pre><h2 id="7-ServletContext对象"><a href="#7-ServletContext对象" class="headerlink" title="7. ServletContext对象"></a>7. ServletContext对象</h2><p>   <strong>ServletContext对象概念：</strong>ServletContext用来存放全局变量，<strong>每个Java虚拟机每个Web项目只有一个ServletContext</strong>,这个ServletContext是由Web服务器创建的，来保证它的<strong>唯一性</strong>。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象通讯。ServletContext对象通常也被称之为Context域对象。<a href="http://www.51gjie.com/javaweb/854.html" target="_blank" rel="noopener">来源：JAVA School</a></p>
<ol>
<li><p><strong>获取ServletContext对象</strong>：要注意两种方法获取的ServletContext对象是同一个，因为一个项目就唯一的一个Servlet对象。</p>
<ul>
<li><p>Request对象的getServletContext方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletContext context1 = request.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>- HttpServlet对象的方法（**自己写的Servlet继承了**HttpServlet）

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletContext context2 = this.getServletContext();</span><br></pre></td></tr></table></figure>
</code></pre><ol start="2">
<li><p><strong>获取MIME类型</strong>：</p>
<ol>
<li><p><strong>MIME（Multipurpose Internet Mail Extensions）类型</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。MIME意为多功能Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。<strong>每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象image等，后面定义具体的种类。</strong><br>常见的MIME类型(通用型)：<br>超文本标记语言文本 .html text/html<br>xml文档 .xml text/xml<br>XHTML文档 .xhtml application/xhtml+xml<br>普通文本 .txt text/plain<br>RTF文本 .rtf application/rtf<br>PDF文档 .pdf application/pdf<br>Microsoft Word文件 .word application/msword<br>PNG图像 .png image/png<br>GIF图形 .gif image/gif<br>JPEG图形 .jpeg,.jpg image/jpeg<br>au声音文件 .au audio/basic<br>MIDI音乐文件 mid,.midi audio/midi,audio/x-midi<br>RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio<br>MPEG文件 .mpg,.mpeg video/mpeg<br>AVI文件 .avi video/x-msvideo<br>GZIP文件 .gz application/x-gzip<br>TAR文件 .tar application/x-tar</p>
</li>
<li><p><strong>ServletContext对象获取MIME类型的方法</strong></p>
<ol>
<li><p>String getMimeType()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String filename = <span class="string">"p.jpg"</span>;</span><br><span class="line">String mimeType = context1.getMimeType(filename);</span><br><span class="line">System.out.println(mimeType);</span><br><span class="line"><span class="comment">//输出 image/jpeg ,表明JPG文件的MIME类型是 image/jpeg</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>3. **域对象：共享数据**

   ServletContext域代表着整个web项目，这个域是最大的，可以共享所有用户所有请求的数据，该对象的声明周期很长，从服务器启动到服务器关闭，一般来说使用该对象存储数据应该谨慎，因为很容易就造成服务器的压力。和Request域类似，也是有三个方法存储数据，获取数据，移除数据：

   1. void setAttribute(String name, Object obj)：存储数据
   2. Object getAttribute(String name)：根据键获取数据
   3. void removeAttribute(String name)：根据键移除数据

4. **获取文件的真实路径（Tomcat服务器路径）**

   1. 方法：String getRealPath(String 资源名称)

      返回资源的真实路径，    根据资源的具体位置不同不同参数有不同的写法，资源位置一般是在：

      - web目录下：**&quot;/a.txt&quot;**
      - web目录下的WEB-INF目录下：**&quot;/WEB-INF/a.txt&quot;**
      - src目录下：**&quot;/WEB-INF/classes/a.txt&quot;**
        - 当然src下的资源还可以通过**classloader**来获取
</code></pre>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/05/28/Lunix基础/" rel="prev" title="Lunix基础">
                Lunix基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">酒徒</p>
              <p class="site-description motion-element" itemprop="description">酒徒的博客</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-概念"><span class="nav-number">1.</span> <span class="nav-text">1. 概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Request对象和Response对象"><span class="nav-number">2.</span> <span class="nav-text">2. Request对象和Response对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-HTTP请求消息数据格式"><span class="nav-number">3.</span> <span class="nav-text">3. HTTP请求消息数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Request对象的功能"><span class="nav-number">4.</span> <span class="nav-text">4.Request对象的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-HTTP响应消息的数据格式"><span class="nav-number">5.</span> <span class="nav-text">5. HTTP响应消息的数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Response对象的功能"><span class="nav-number">6.</span> <span class="nav-text">6. Response对象的功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-ServletContext对象"><span class="nav-number">7.</span> <span class="nav-text">7. ServletContext对象</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">酒徒</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
