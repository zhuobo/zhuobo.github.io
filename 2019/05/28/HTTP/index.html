<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>酒徒</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="HTTP1. 概念超文本传输协议（HyperText Transport Protocol），基于TCP/IP的应用层协议，默认端口号是80，基于请求响应模型（一次请求对应一次响应），是无状态的（每次请求是项目独立的）。  1.0版本：每次请求响应都会建立一次HTTP连接 1.1版本：HTTP连接会被复用，一次连接可以传输多次数据  2. Request对象和Response对象 服务器在收到一次">
<meta property="og:type" content="article">
<meta property="og:title" content="酒徒">
<meta property="og:url" content="http://yoursite.com/2019/05/28/HTTP/index.html">
<meta property="og:site_name" content="酒徒">
<meta property="og:description" content="HTTP1. 概念超文本传输协议（HyperText Transport Protocol），基于TCP/IP的应用层协议，默认端口号是80，基于请求响应模型（一次请求对应一次响应），是无状态的（每次请求是项目独立的）。  1.0版本：每次请求响应都会建立一次HTTP连接 1.1版本：HTTP连接会被复用，一次连接可以传输多次数据  2. Request对象和Response对象 服务器在收到一次">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-04-26T13:44:50.213Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="酒徒">
<meta name="twitter:description" content="HTTP1. 概念超文本传输协议（HyperText Transport Protocol），基于TCP/IP的应用层协议，默认端口号是80，基于请求响应模型（一次请求对应一次响应），是无状态的（每次请求是项目独立的）。  1.0版本：每次请求响应都会建立一次HTTP连接 1.1版本：HTTP连接会被复用，一次连接可以传输多次数据  2. Request对象和Response对象 服务器在收到一次">
  
    <link rel="alternate" href="/atom.xml" title="酒徒" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">酒徒</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-HTTP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/28/HTTP/" class="article-date">
  <time datetime="2019-05-28T15:15:48.748Z" itemprop="datePublished">2019-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>超文本传输协议（HyperText Transport Protocol），基于TCP/IP的应用层协议，默认端口号是<strong>80</strong>，基于请求响应模型（一次请求对应一次响应），是无状态的（每次请求是项目独立的）。</p>
<ol>
<li>1.0版本：每次请求响应都会建立一次HTTP连接</li>
<li>1.1版本：HTTP连接会被复用，一次连接可以传输多次数据</li>
</ol>
<h2 id="2-Request对象和Response对象"><a href="#2-Request对象和Response对象" class="headerlink" title="2. Request对象和Response对象"></a>2. Request对象和Response对象</h2><ol>
<li><strong>服务器在收到一次请求消息后做的事情：</strong><ol>
<li>Tomcat服务器根据请求URL的资源路径创建对应的Servlet对象</li>
<li>Tomcat服务器创建Request对象和Response对象，其中在Request对象中封装请求消息数据</li>
<li>Tomcat将Request对象和Response对象传递给service方法，并且通过Servlet对象调用该方法</li>
<li>在该方法中，可以根据Request对象获取请求消息数据，并通过Response对象设置响应消息数据</li>
<li>服务器在给浏览器做出响应之前会从Response对象中得到设置好的响应消息数据</li>
</ol>
</li>
</ol>
<h2 id="3-HTTP请求消息数据格式"><a href="#3-HTTP请求消息数据格式" class="headerlink" title="3. HTTP请求消息数据格式"></a>3. HTTP请求消息数据格式</h2><ol>
<li><p>Request对象的继承体系结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServletRequest -- 接口</span><br><span class="line">	|继承</span><br><span class="line">HttpServletRequest -- 接口</span><br><span class="line">	|实现</span><br><span class="line">RequestFacade -- 实现类</span><br></pre></td></tr></table></figure>
<p>该实现类有Apache编写，<code>org.apache.catalina.connector.RequestFacade</code></p>
</li>
<li><p>请求行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求方法 请求URL 请求协议/版本</span><br></pre></td></tr></table></figure>
<ol>
<li>请求方法：HTTP有7中请求方式，常用的有两种<ol>
<li>GET：<ol>
<li>请求参数在请求行中（在URL后）</li>
<li>请求的URL长度有限制</li>
<li>相对没那么安全</li>
</ol>
</li>
<li>POST：<ol>
<li>请求参数在请求体中</li>
<li>请求URL长度没有限制</li>
<li>相对安全</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>请求头</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求头名称：请求头值</span><br></pre></td></tr></table></figure>
<p>常用的请求头：</p>
<ol>
<li>User-Agent：告诉服务器浏览器版本信息<ol>
<li>可以用来解决浏览器版本兼容性问题</li>
</ol>
</li>
<li>Accept：可以接收、解析的信息</li>
<li>Connection：keep-alive，1.1版本、连接复用</li>
<li>Referer：Referer: <a href="http://localhost/login.html，告诉服务器，当前请求是从哪里来的" target="_blank" rel="noopener">http://localhost/login.html，告诉服务器，当前请求是从哪里来的</a><ol>
<li>作用有：防止盗链、统计流量来源数量等</li>
</ol>
</li>
</ol>
</li>
<li><p>请求空行：就是一个空行，用来分隔请求头和请求体</p>
</li>
<li><p>请求体：封装POST请求消息的请求参数的</p>
<ol>
<li>GET方法没有请求体，POST方法的请求体为 name=值</li>
</ol>
</li>
<li><p>一个简单的完整的请求消息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">POST /demo3 HTTP/1.1 -- 请求行</span><br><span class="line">Host: localhost</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Content-Length: 13</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Origin: http://localhost</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3</span><br><span class="line">x-xyst: KHgiNG8mJjdUdnVPSnIxRYrXQyBkSfrS47T_FU7_372biFAU4QMaRw==</span><br><span class="line">Referer: http://localhost/login.html</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: en-US,en;q=0.9,is;q=0.8,zh;q=0.7,zh-CN;q=0.6,zh-TW;q=0.5,ja;q=0.4,nl;q=0.3</span><br><span class="line">Cookie: Idea-ba272247=a33d6b38-3af8-4b08-b337-f1e8c3cc1311; JSESSIONID=F43308216BD55AAF85AF182BEA04824F</span><br><span class="line">														-- 请求空行</span><br><span class="line">														</span><br><span class="line">username=bobby -- 请求体</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="4-Request对象的功能"><a href="#4-Request对象的功能" class="headerlink" title="4.Request对象的功能"></a>4.Request对象的功能</h2><ol>
<li><p><strong>获取请求消息数据</strong></p>
<ol>
<li><p>获取请求行数据，假如请求行是这个：GET /servlet/demo3?username=aaa HTTP/1.1</p>
<ol>
<li>获取请求方式（GET）：String getMethod()</li>
<li>(*)获取虚拟目录(/servlet)：String getContextPath()，一般用来动态获取虚拟目录，而不是写死。</li>
<li>获取Servlet路径（/demo3）：String getServletPath()</li>
<li>获取get方式的请求参数(username=aaa)：String getQueryString()</li>
<li>(*)获取请求的URI（/servlet/demo3）<ol>
<li>String getRequestURI():          /servlet/demo3</li>
<li>String getRequestURL():         <a href="http://localhost/servlet/demo3" target="_blank" rel="noopener">http://localhost/servlet/demo3</a></li>
</ol>
</li>
<li>获取协议版本(HTTP/1.1)：String getProtocol()</li>
<li>获取客户机的IP地址：String getRemoteAddr()</li>
</ol>
</li>
<li><p>获取请求头数据</p>
<ol>
<li>String getHeader(String name)：根据请求头名称，获取请求头的值</li>
<li>Enumeration&lt; String &gt; getHeaderNames()：获取所有的请求头名称</li>
</ol>
</li>
<li><p>获取请求体的数据</p>
<ol>
<li><p>只有POST方法才有请求体，在请求体中封装了POST请求的请求参数</p>
</li>
<li><p>步骤：</p>
<ol>
<li><p>获取流对象</p>
<ol>
<li>BufferReader getReader()：获取字符输入流，只能操作字符数据</li>
<li>ServletInputStream getInputStream()：获取字节输入流，可以操作所有的数据类型</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>2. 从流对象里拿到参数数据



   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;</span><br><span class="line">          BufferedReader br = request.getReader();</span><br><span class="line">          String str = null;</span><br><span class="line">          while ((str = br.readLine()) != null) &#123;</span><br><span class="line">              System.out.println(str);// username=bbbb&amp;password=bbbb</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ol start="2">
<li><p><strong>其他的功能</strong></p>
<ol>
<li><p>获取请求参数的通用方式(兼容GET和POST)</p>
<ol>
<li>String getParameter(String name) ：根据参数名获取参数值</li>
<li>String[] getParameterValues(String name)：根据参数名获取参数值的数组，针对复选框的情况</li>
<li>Enumeration&lt; String &gt; getParameterNames()：获取所有请求的参数名</li>
<li>Map&lt;String, String[]&gt; getParameterMap()：获取所有参数的map集合</li>
</ol>
<p><strong>注意：</strong>获取请求参数时会可能出现乱码情况，修改编码格式即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(&quot;utf-8&quot;); -- utf-8为输入参数的注册页面格式</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><p>请求转发：一种在服务器内部的资源跳转方式</p>
<ol>
<li><p>通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)</p>
</li>
<li><p>RequestDispatcher对象调用forward方法进行转发：forward(ServletRequest request，ServletResponse)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;demo8888888888888888&quot;);</span><br><span class="line">request.getRequestDispatcher(&quot;/requestDemo7&quot;).forward(request,response);</span><br><span class="line"></span><br><span class="line">// 这样不仅可以访问到demo8，还可以访问到demo7，因为在demo8里请求转发到demo7</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求转发的特点：</p>
<ol>
<li>浏览器地址栏的路径不会改变</li>
<li>只能请求转发本服务器内部的资源，不能请求其他资源</li>
<li>转发只是一次请求，不会因为访问了多个资源就是多个请求</li>
</ol>
</li>
</ol>
</li>
<li><p>共享数据：请求转发实际上是两个Servlet之间的通信，可以使用共享数据的方法进行通信，一个Servlet了可以存储数据，另一个Servlet可以读取数据</p>
<ol>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域：值得是一次请求的范围，该范围可以因为请求转发而被扩大，一般用于在发生请求转发的多个资源中进行数据的共享。</li>
<li>方法：<ol>
<li>void setAttribute(String name, Object obj)：存储数据</li>
<li>Object getAttribute(String name)：根据键获取数据</li>
<li>void removeAttribute(String name)：根据键移除数据</li>
</ol>
</li>
</ol>
</li>
<li><p>获取ServletContext</p>
<ol>
<li>方法：servletContext getServletContext()</li>
</ol>
</li>
</ol>
<h2 id="5-HTTP响应消息的数据格式"><a href="#5-HTTP响应消息的数据格式" class="headerlink" title="5. HTTP响应消息的数据格式"></a>5. HTTP响应消息的数据格式</h2><ol>
<li><p><strong>响应行</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<p>组成：协议版本、响应的状态码、响应的状态</p>
<p>状态码对应的状态：</p>
<ol>
<li>1XX：服务器接收到信息，但是没有完成，在等待一段时间后，发送1XX给客户端</li>
<li>2XX：成功，如：200</li>
<li>3XX：重定向，如：302（重定向）、304（访问缓存）</li>
<li>4XX：客户端错误，如：404（访问路径没有对应资源）、405（请求方法没有对应的doGet或者doPost方法）</li>
<li>5XX：服务器内部出现异常，如：500（服务器内部出现异常）</li>
</ol>
</li>
<li><p><strong>响应头</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html;charset=UTF-8</span><br><span class="line">Content-Length: 101</span><br><span class="line">Date: Thu, 25 Apr 2019 07:43:37 GMT</span><br></pre></td></tr></table></figure>
<p>格式：响应头名称：响应值</p>
<p>常见的响应头：</p>
<ol>
<li>Content-Type：服务器告知客户端本次响应的数据格式以及编码方式</li>
<li>Content-Length：响应体的长度，以字节为单位</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体的数据<ol>
<li>值为 <code>in-line</code>：默认值，在当前页面打开响应体</li>
<li>值为 <code>attachment;filename=xxx</code>：以附件形式打开响应体，一般用于文件下载</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>响应空行</strong></p>
</li>
<li><p><strong>响应体</strong>：真实的传输的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;index.jsp&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    response.jsp</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-Response对象的功能"><a href="#6-Response对象的功能" class="headerlink" title="6. Response对象的功能"></a>6. Response对象的功能</h2><ol>
<li><p><strong>设置响应消息</strong></p>
<ol>
<li>设置响应行：HTTP/1.1 200 OK<ol>
<li>设置状态码：setStatus(int sc)</li>
</ol>
</li>
<li>设置响应头：setHeader(String name, String value)</li>
<li>设置响应体：<ul>
<li>使用步骤：<ol>
<li>获取输出流<ol>
<li>获取字节输出流：ServletOutputStream getOutputStream()</li>
<li>获取字符输出流：PrintWriter getWrite()</li>
</ol>
</li>
<li>使用输出流影数据输出到浏览器</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>Response对象的功能：</strong></p>
<ol>
<li><p><strong>实现重定向</strong>：</p>
<ol>
<li>代码实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(302);</span><br><span class="line">response.setHeader(&quot;location&quot;, &quot;/response/ResponseDemo2&quot;);</span><br><span class="line">/***********或者**************/</span><br><span class="line">response.sendRedirect(&quot;/response/ResponseDemo2&quot;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>重定向和转发的区别</p>
<p>|   重定向（redirect）   |      转发（forward）       |<br>| :——————–: | :————————: |<br>|     地址栏发生变化     |      地址栏不发生变化      |<br>| 可以访问其他站点的资源 | 只能访问本服务器内部的资源 |<br>|    重定向是两次请求    |       转发是一次请求       |</p>
<p><strong>解析：</strong>由于转发是一次请求，因此可以使用Request对象来共享数据，但是重定向是两次请求，因此有两个Request对象，不能通过Request对象共享数据。</p>
</li>
<li><p>路径的写法：</p>
</li>
</ol>
</li>
<li><p><strong>输出数据</strong>：</p>
<ol>
<li><p>服务器输出<strong>字符</strong>到浏览器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取字符输出流之前先设置编码格式为utf-8，避免中文乱码</span></span><br><span class="line">response.setContentType(<span class="string">"text/html; charset=utf-8"</span>);</span><br><span class="line">PrintWriter writer = response.getWriter();</span><br><span class="line">writer.write(<span class="string">"&lt;h1&gt;我写几个中文吧，hello, i am a response message!&lt;/h1&gt;"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>2. 服务器输出**字节**浏览器：（一般用来输出图片等信息）

   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">"text/html; charset = utf-8"</span>);</span><br><span class="line">ServletOutputStream os = response.getOutputStream();</span><br><span class="line">os.write(<span class="string">"猪八戒"</span>.getBytes());</span><br></pre></td></tr></table></figure>


3. 验证码的小demo

   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/checkCodeServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CheckCodeServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> width  = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">50</span>;</span><br><span class="line">        BufferedImage image = <span class="keyword">new</span> BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 填充背景色</span></span><br><span class="line">        Graphics graphics = image.getGraphics();</span><br><span class="line">        graphics.setColor(Color.pink);</span><br><span class="line">        graphics.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 画边框</span></span><br><span class="line">        graphics.setColor(Color.BLUE);</span><br><span class="line">        graphics.drawRect(<span class="number">0</span>, <span class="number">0</span>, width - <span class="number">1</span>, height - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机画四个字母</span></span><br><span class="line">        String str = <span class="string">"ABCDEFGHIJKLMNOPQTSTUVWXYZabcdefghijkilmnopqrstuvwxyz0123456789"</span>;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> index = random.nextInt(str.length());</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(index);</span><br><span class="line">            graphics.drawString(c+<span class="string">""</span>, i * <span class="number">20</span>, height / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机画干扰线</span></span><br><span class="line">        graphics.setColor(Color.GREEN);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x1 = random.nextInt(width);</span><br><span class="line">            <span class="keyword">int</span> y1 = random.nextInt(height);</span><br><span class="line">            <span class="keyword">int</span> x2 = random.nextInt(width);</span><br><span class="line">            <span class="keyword">int</span> y2 = random.nextInt(height);</span><br><span class="line">            graphics.drawLine(x1, y1, x2, y2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> jpg = ImageIO.write(image, <span class="string">"jpg"</span>, response.getOutputStream());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


   **验证码切换**

   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> image = <span class="built_in">document</span>.getElementById(<span class="string">"checkCode"</span>);</span><br><span class="line">        image.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 由于其实每次都是访问一样的Servlet，因此要加时间戳，欺骗服务器每次请求不一样，这样就可以不访问浏览器的本地缓存</span></span><br><span class="line">            <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">            image.src = <span class="string">"/response/checkCodeServlet"</span> + <span class="string">"?"</span> + date;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"change"</span>);</span><br><span class="line">        link.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">            image.src = <span class="string">"/response/checkCodeServlet"</span> + <span class="string">"?"</span> + date;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
</code></pre><h2 id="7-ServletContext对象"><a href="#7-ServletContext对象" class="headerlink" title="7. ServletContext对象"></a>7. ServletContext对象</h2><p>   <strong>ServletContext对象概念：</strong>ServletContext用来存放全局变量，<strong>每个Java虚拟机每个Web项目只有一个ServletContext</strong>,这个ServletContext是由Web服务器创建的，来保证它的<strong>唯一性</strong>。由于一个WEB应用中的所有Servlet共享同一个ServletContext对象，因此Servlet对象之间可以通过ServletContext对象通讯。ServletContext对象通常也被称之为Context域对象。<a href="http://www.51gjie.com/javaweb/854.html" target="_blank" rel="noopener">来源：JAVA School</a></p>
<ol>
<li><p><strong>获取ServletContext对象</strong>：要注意两种方法获取的ServletContext对象是同一个，因为一个项目就唯一的一个Servlet对象。</p>
<ul>
<li><p>Request对象的getServletContext方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletContext context1 = request.getServletContext();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>- HttpServlet对象的方法（**自己写的Servlet继承了**HttpServlet）

  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServletContext context2 = this.getServletContext();</span><br></pre></td></tr></table></figure>
</code></pre><ol start="2">
<li><p><strong>获取MIME类型</strong>：</p>
<ol>
<li><p><strong>MIME（Multipurpose Internet Mail Extensions）类型</strong>：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。MIME意为多功能Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。<strong>每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象image等，后面定义具体的种类。</strong><br>常见的MIME类型(通用型)：<br>超文本标记语言文本 .html text/html<br>xml文档 .xml text/xml<br>XHTML文档 .xhtml application/xhtml+xml<br>普通文本 .txt text/plain<br>RTF文本 .rtf application/rtf<br>PDF文档 .pdf application/pdf<br>Microsoft Word文件 .word application/msword<br>PNG图像 .png image/png<br>GIF图形 .gif image/gif<br>JPEG图形 .jpeg,.jpg image/jpeg<br>au声音文件 .au audio/basic<br>MIDI音乐文件 mid,.midi audio/midi,audio/x-midi<br>RealAudio音乐文件 .ra, .ram audio/x-pn-realaudio<br>MPEG文件 .mpg,.mpeg video/mpeg<br>AVI文件 .avi video/x-msvideo<br>GZIP文件 .gz application/x-gzip<br>TAR文件 .tar application/x-tar</p>
</li>
<li><p><strong>ServletContext对象获取MIME类型的方法</strong></p>
<ol>
<li><p>String getMimeType()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String filename = <span class="string">"p.jpg"</span>;</span><br><span class="line">String mimeType = context1.getMimeType(filename);</span><br><span class="line">System.out.println(mimeType);</span><br><span class="line"><span class="comment">//输出 image/jpeg ,表明JPG文件的MIME类型是 image/jpeg</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<pre><code>3. **域对象：共享数据**

   ServletContext域代表着整个web项目，这个域是最大的，可以共享所有用户所有请求的数据，该对象的声明周期很长，从服务器启动到服务器关闭，一般来说使用该对象存储数据应该谨慎，因为很容易就造成服务器的压力。和Request域类似，也是有三个方法存储数据，获取数据，移除数据：

   1. void setAttribute(String name, Object obj)：存储数据
   2. Object getAttribute(String name)：根据键获取数据
   3. void removeAttribute(String name)：根据键移除数据

4. **获取文件的真实路径（Tomcat服务器路径）**

   1. 方法：String getRealPath(String 资源名称)

      返回资源的真实路径，    根据资源的具体位置不同不同参数有不同的写法，资源位置一般是在：

      - web目录下：**&quot;/a.txt&quot;**
      - web目录下的WEB-INF目录下：**&quot;/WEB-INF/a.txt&quot;**
      - src目录下：**&quot;/WEB-INF/classes/a.txt&quot;**
        - 当然src下的资源还可以通过**classloader**来获取
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/28/HTTP/" data-id="cjw7ye7g500019g9gsjzmsz9q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/05/28/Lunix基础/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Lunix基础</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/05/28/HTTP/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/05/28/Lunix基础/">Lunix基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 酒徒<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>