<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python函数]]></title>
    <url>%2F2019%2F06%2F13%2FPython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[一、定义函数使用 def语句定义函数，依次写出函数名、括号、参数、冒号，然后在缩进的代码块中写函数体，使用return语句返回。当没有return语句时，默认提供一个，但是返回的是None，返回None可以简写为return。 12def sum_of_two(x, y): return x + y 空函数，如果一个函数什么都不做，或者暂时还没想好怎么实现，只是希望程序可以跑起来，那么可以使用pass语句。 12def nop(): pass 多个返回值 Python可以提供多个返回值，事实上返回的是一个tuple 12def function(x, y): return x, y 二、函数的参数1. 位置参数在调用函数时，根据函数定义的参数位置来传递参数，参数的个数不能少、位置要一一对应。 2. 默认参数定义函数时给出某些参数的默认值，在调用的的时候不用传递这些有默认值的参数，这些参数将会使用默认值，当然也可以传递。要注意的是，无论是定义函数，还是调用函数默认参数都必须在位置参数之后。 123456789def pow(x, n = 2): ans = 1 while n &gt;= 1: ans *= x n -= 1 return ansprint(pow(3)) # 9print(pow(3, 3)) # 27 默认参数应该指向一个不可变的对象，比如整数、字符串、None等，如果默认参数指向了可变的对象比如list，一旦list在函数中被改变，那么下次调用函数使用的默认参数就是被改变了的参数，出现不希望出现的情况。 3. 可变参数可变参数指的是传递的参数个数可以变化，可以是任意个参数。在没有使用可变参数的方法定义函数的时候，又希望函数的参数可以变化，那么就可以将函数参数定义为一个list。 12345def calc(nums): ans = 0 for num in nums: ans += num * num; return ans 这样在调用的时候也可以传递多个参数，但是要先组装为一个list 1print(calc([1, 2, 3])) 在上面定义函数的基础上，参数前加一个*,表示是可变参数，函数体都不需要改变即可直接在调用函数的时候传递任意个参数。 123456def calc(*nums): ans = 0 for num in nums: ans += num * num; return ans 调用函数，不需要组装list，或者tuple 1print(calc(1, 2, 3)) 函数定义为可变参数之后，如果参数又是一个list，那么还是可以直接传递list作为参数，只需要在list名之前加一个*，这就表示把list的元素变为可变参数传递到函数，并且在调用的时候自动组装成一个tuple，*list`表示把list的元素作为可变参数传递给函数。 12list = (1, 2, 3, 4)print(calc(*list)) 4. 关键字参数可变参数允许传递任意个参数，在函数调用的时候自动组装为一个tuple，二关键字参数也是允许传递任意个含有参数名的参数，在函数调用的时候自动组装为一个dict。 12345678def show_user(username, age, **kw): print('username:', username, 'age:', age, 'other:',kw)show_user('zhuobo', 19)show_user('zhuobo', 19, city = '广州')show_user('zhuobo', 19, city = '广州', gender = 'male') 输出： 123username: zhuobo age: 19 other: &#123;&#125;username: zhuobo age: 19 other: &#123;'city': '广州'&#125;username: zhuobo age: 19 other: &#123;'city': '广州', 'gender': 'male'&#125; 当然在传递关键字参数的时候，也可以先组装一个dict，然后使用类似于*list的方式传递关键字参数。**kw表示把dict的所有key-value用关键字参数传递到函数的**kw参数，**kw将获取一份dict的拷贝。 12dict = &#123;'city':'广州', 'gender':'male'&#125;show_user('zhuobo', 19, **dict) 5. 命名关键字参数对于关键子参数，调用函数的时候可以传递任意个关键字参数，如果要限制关键字参数的名字，就需要命名关键字参数。和关键字参数**kw所不同的是，需要在位置参数和命名关键字参数之间写一个*作为分隔符号。如：要限制输入的关键字参数只能是city，hobby，那么就可以这么定义函数： 12def show_user(username, age, *, city, hobby): print(username, age, city, hobby) 调用方式： 1show_user('zhuobo', 19, city = 'Guangzhou', hobby = 'football') 输出： 1zhuobo 19 Guangzhou football 如果是函数已经定义了一个可变参数，那么就无需使用*作为分隔符，直接写命名关键字参数即可 12def show_user(username, age, *args, city, hobby): print(username, age, city, hobby) 注意： 函数调用时必须，命名关键字参数必须写上参数名，否则解释器无法区分位置参数和命名关键字参数； 如果没有可变参数，位置参数和命名关键字参数之间必须使用*作为分隔符；]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础]]></title>
    <url>%2F2019%2F06%2F12%2FPython%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、数据类型和变量1.数据类型 整数 浮点数 字符串，字符串使用单引号&#39;&#39;,或者双引号&quot;&quot;括起来，如果字符串中包含单引号或者双引号，那么应该转义字符\标记； 布尔值，只有False、True，注意首字母大写，布尔值的运算与或非使用and，or，not表示； 空值，使用None表示空值，空值不是0，就是表示什么都不是，而0是一个整数，有意义的； 2. 变量Python的变量类型是不固定的，被成为动态语言，与之对应的是静态语言。静态语言在定义的时候必须指定数据类型，如果为变量赋值，数据类型不匹配还会报错，java、C++等便是静态语言。 常量指的是不能变的变量，也即是值是固定的，Python中一般使用全部大写表示常量，如：PI = 3.141592653。但是这只是一种约定俗成，如果非要改变PI的值也是可以。 二、字符和编码 ASCII码：使用1个字节存储数据，包括英文字符、数字、一些常见英文符号; GB2312：中国制定的包括中文的编码 Unicode：为了将所有语言统一到一个编码，以解决不同地区使用不同编码集出现的乱码问题而制定的编码。Unicode编码通常是2个字节，如果非常生僻的字符可能会用到4个字节。 UTF-8：可编长编码，Unicode解决了乱码问题，但是会使本来只用一个字节编码的常用英文字母、数字等字符占用存储空间变为两倍。因此UTF-8将常用英文字母、数字编码为1个字节、中文汉字通常为3个字节、很生僻的字符会用到4-6个字节。 一般来说，在计算机内存中使用Unicode编码，当需要保存到硬盘或者在网络上传输就转换为UTF-8。 格式化输出字符串：Python使用类似于C语言的方式格式化字符串，在字符串的内部，%s表示用字符串替换，%d表示用整数替换。如果有多个占位符，后面使用 % 运算符再跟上相应的变量，注意要一一对应。 1'My name is %s, and I have got %d yuan for my work!' % ('zhuobo', salary) 常用的占位符： 占位符 替换 %s 字符串 %d 整数 %f 浮点数 %x 十六进整数 其中，替换的整数或者浮点数还可以指定是否在前面补0，或者占用的位数。 占用3位： 12'占用3位的整数：%3d' % 5#输出：占用3位的整数： 5' 前面补0： 12'占用3位的整数：%03d' % 5#输出：占用3位的整数：005' 三、list和tuple1. listlist（列表）是Python内置的一种数据类型，是有序的集合，可以随机存取其中的元素。 list使用中括号将数据括起来，数据之间用,分隔; 索引从0开始，最后一个元素是list[-1]，也可以是list[len(list) - 1]; list是一个有序的可变长度列表，可以使用append()追加元素; 1list.append('hello') 使用insert()将元素插入到指定的位置，以下表示插入到0号位置 1list.insert(0, 'hello') 使用pop()删除末尾元素，返回值为被删除元素 12# 空参数表示删除末尾元素var = list.pop() 使用pop(pos)删除指定位置元素，pos为指定的索引，返回值为被删除元素 12# 参数表示指定位置var = list.pop(pos) 一个list可以存储不同类型的元素 1list = ['asdf', 12, 13.4] list里面也可以存储list，如果要获取alice，相当于一个二维数组 123456&gt;&gt;&gt; list['asdf', 12, 13.4, ['david', 'alice']]&gt;&gt;&gt; len(list)4&gt;&gt;&gt; list[3][1] # 二维数组'alice' 2. tupletuple是另一种有序列表，使用()包裹起来，与list的区别是一旦tuple被初始化就不能修改，因此没有append()、insert()等修改元素的方法。tuple和list一样可以获取元素，但是不能被重新赋值为另外的元素，tuple不能修改的意义在于可以增强安全性，如果可以，就应该尽量使用tuple而不是list。要注意的是，定义一个tuple，在定义的时候就必须初始化，也就是确定tuple的元素。 1234567# 定义一个元组tuple1 = ('david', 13, 'alice', 14.5)# 定义一个空的元组tuple2 = ()# 定义一个只有1个元素的元组，当这个元素是数值时，为了区别数值，所有一个元素的元组在那个元素后面加一个逗号tuple3 = (1,) # 这是一个元组1个元素的元组，该元素是数字1tuple4 = (1) # 这是整数1, 不是元组 tuple不变指的是每个索引指向的元素不变，也就是本来tuple的元素是&#39;a&#39;,那么就一直是 &#39;a&#39;，而不能变成来其他的元素，如果指向的是一个可变的元素，比如list，那么list还是可以改变，这时候改变的是list的元素，而不是tuple的元素。 四、条件判断if_else句式： 1234if e: do somethingelse: do something if_elif_else句式： 12345678if e1: do somethingelif e2: do somethingelif e3: do somethingelse: do something 五、循环1. for x in ...循环for x in ...循环用于遍历list或者tuple，迭代取出存储其中的元素。 12345# for 循环names = ['zhuobo', 'david', 'alice']for name in names: print('Hello,', name) 1234567# list函数生成list，range函数生成生成序列sum = 0mylist = list(range(101))for num in mylist: sum += numprint(sum) 使用索引的for循环，使用函数enumerate()，事实上是将list组装成了类似于[(‘aaa’, 1), (‘bbb’, 2), (‘ccc’, 3)]这种形式。 1234names = ['zhuobo', 'david', 'alice']for index, name in enumerate(names): print(index,':', name) 2.while循环当循环条件不再满足，跳出循环 12345678# 100以内的奇数的和n = 1sum = 0while n &lt; 100: sum += n n += 2print(sum) 3. break、continuebreak控制直接跳出循环、continue控制跳过本轮循环，继续下一轮循环，这两个语句一般都会配合判断语句使用，符合条件就执行。 六、dict、set1. dict Python内置了对字典的支持，字典在其他语言中成为Map，也就是使用键-值对存储的数据结构。 123d = &#123;'Alice': 80, 'Zhuobo':90, 'David':88&#125;print('Alice:', d['Alice']) 字典中的键不允许重复，可以使用in判断是键是否在字典中： 1234&gt;&gt;&gt; 'zhuobo' in dFalse&gt;&gt;&gt; 'Zhuobo' in dTrue 除了使用索引的方法获取值，字典还提供了get()方法获取值，如果key不存在就返回None，也可以返回指定的值。 1234&gt;&gt;&gt; d.get('zhuobo', -1)-1&gt;&gt;&gt; d.get('Zhuobo')90 要注意的是，作为key的数据必须是不可变的，比如数字、字符串等，但是list是可变的数据，因此不可作为字典的键。这是因为字典使用哈希算法根据键获取值，而如果键是可变的，哈希的结果会变化。 2. set创建一个set，需要提供一个list，set的元素不重复，没有顺序。 12&gt;&gt;&gt; set(['zhuob', 12, 14.2, 12, 12])&#123;12, 14.2, 'zhuob'&#125; add(key)方法添加数据 123&gt;&gt;&gt; mySet.add('Alice')&gt;&gt;&gt; mySet&#123;'Alice', 12, 14.2, 'zhuob'&#125; remove(key)方法删除数据 123&gt;&gt;&gt; mySet.remove(12)&gt;&gt;&gt; mySet&#123;'Alice', 14.2, 'zhuob'&#125; 并集、交集 123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([4, 2, 3])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125; 集合也不可存储可变数据，因为这样无法判断两个数据是否相等，无法去重。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2解决表单重复提交]]></title>
    <url>%2F2019%2F06%2F11%2Fstruts2%E8%A7%A3%E5%86%B3%E8%A1%A8%E5%8D%95%E9%87%8D%E5%A4%8D%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[一、表单的重复提交在用户填写完表单之后、提交表单之后，有可能会出现表单的重复提交，出现这种情况有可能有以下几种原因： 网络状态不好，多次点击提交按钮； 提交表单后，点击浏览器的刷新按钮； 提交表单后，点击浏览器的后退按钮，再次点击提交按钮。 二、表单重复提交的解决方案 使用JavaScript设置一个状态位，第一次点击之前设为true，表示用户可以提交表单，第一次点击之后设置为false，不允许用户提交或者直接将提交按钮disabled；但是这种方法只针对以上三种情况中的第一种有效，无法避免第二、第三种情况的发生； 使用验证码的方式：用户填写的表单包括服务器生成的验证码，当表单数据提交到服务器之后，服务器从session中获取服务器自己生成的验证码，获取之后从session中删除验证码，以保证该验证码的一次性；这样，服务器每次收到客户端的请求都先判断验证码是否一致，如果不一致自然便是重复提交（或者验证码错误）而无需处理数据； struts的token可以解决这个问题：使用&lt;s:token&gt;生成一个令牌，再配合 tokensession拦截器 创建一个表单，在表单里添加一个隐藏的&lt;s:token&gt;标签; 1234567&lt;form action="$&#123;pageContext.request.contextPath&#125;/student/login.do"&gt; &lt;s:textfield name="username" label="用户名"/&gt; &lt;s:textfield name="password" label="密码"/&gt; &lt;%--token标签--%&gt; &lt;s:token /&gt; &lt;input value="登录" type="submit"&gt;&lt;/form&gt; 在struts.xml中配置 tokensession拦截器 1234567&lt;action name="login" class="cn.zhuobo.web.action.StudentAction" method="login" &gt; &lt;!--由于配置了自定义的不在默认拦截器里面的拦截器，因此要手动加上默认拦截器defaultStack--&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;interceptor-ref name="tokenSession"/&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;result name="invalid.token"&gt;/invalid.jsp&lt;/result&gt;&lt;/action&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts标签]]></title>
    <url>%2F2019%2F06%2F08%2Fstruts%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[一、struts的标签struts提供的简化视图页面编写的标签，要使用struts的标签，首先要引入：&lt;%@ taglib uri =&quot;/struts-tags&quot; prefix =&quot;s&quot; %&gt;。 二、常用标签1. 迭代标签当一个Action类提供了一个属性，并且提供了该属性的getter方法，那么该属性会自动被Struts2保存到值栈之中，也就是不用专门获取值栈在存储数据。 1234567891011121314151617181920public class StudentAction extends ActionSupport &#123; private List&lt;Student&gt; studentList; // Action提供属性，并且提供属性的getter方法，那么属性就会被struts2自动存储到值栈 // jsp从值栈中获取数据 public List&lt;Student&gt; getStudentList() &#123; return studentList; &#125; public String list() &#123; // 如果是使用了struts2，jsp一般从值栈中获取数据 // 如果是使用了servlet，jsp一般从request域中获取数据 studentList = new ArrayList&lt;Student&gt;(); studentList.add(new Student("孙悟红", 16, "花果山")); studentList.add(new Student("红孩儿", 17, "火焰山")); studentList.add(new Student("铁山公主", 18, "芭蕉洞")); studentList.add(new Student("紫霞仙子", 19, "盘丝洞")); return SUCCESS; &#125;&#125; 遍历标签的使用： value：是OGNL表达式，首先从值栈中获取； var：遍历使用的临时变量，值得注意的是Struts会把当前遍历到的变量以var为键，变量指向的对象为值存储到contextMap中，因此获取var的对象要从contextMap中获取； status：用于记录变量的一些属性 boolean isOdd()：奇数 boolean iseven()：偶数 boolean isFirst()：第一个 boolean isLast()：最后一个 int getIndex()：获取索引，从0开始 int getCount()：获取序号，从1开始 12345678910111213141516171819&lt;%--studentList是存储在值栈中的，但是每遍历一次就会将student存储到contextMap中，因此OGNL获取要加#--%&gt; &lt;s:iterator value="studentList" var="student" status="st"&gt; &lt;s:if test="#st.odd"&gt; &lt;tr class="odd"&gt; &lt;td&gt;$&#123;st.count&#125;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.name"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.age"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.city"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:if&gt; &lt;s:if test="#st.even"&gt; &lt;tr class="even"&gt; &lt;td&gt;$&#123;st.count&#125;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.name"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.age"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.city"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:if&gt; &lt;/s:iterator&gt; 2. OGNL投影OGNL投影指的是根据给定条件过滤集合： ?#：过滤所有符合条件的元素，如studentList.{?#this.age &gt; 17} ^#：过滤第一个符合条件的元素，如studentList.{^#this.age &gt; 17} $#：过滤最后一个符合条件的元素，如studentList.{$#this.age &gt; 17} 123456789101112131415161718&lt;s:iterator value="studentList.&#123;?#this.age &gt; 17&#125;" var="student" status="st"&gt; &lt;s:if test="#st.odd"&gt; &lt;tr class="odd"&gt; &lt;td&gt;$&#123;st.count&#125;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.name"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.age"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.city"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:if&gt; &lt;s:if test="#st.even"&gt; &lt;tr class="even"&gt; &lt;td&gt;$&#123;st.count&#125;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.name"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.age"/&gt;&lt;/td&gt; &lt;td&gt;&lt;s:property value="#student.city"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:if&gt;&lt;/s:iterator 如果是值需要展示指定的属性，比如只需要展示城市，遍历的时候不用指定var，这样默认遍历取出的值便是放在值栈栈顶，如studentList.{city}便是将该集合所有的Student的city属性存储到值栈栈顶，从栈顶取出值即可。 12345678910111213&lt;s:iterator value="studentList.&#123;city&#125;" status="st"&gt; &lt;s:if test="#st.odd"&gt; &lt;tr class="odd"&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:if&gt; &lt;s:if test="#st.even"&gt; &lt;tr class="even"&gt; &lt;!-- 不写value,直接从值栈栈顶取值 --&gt; &lt;td&gt;&lt;s:property/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/s:if&gt;&lt;/s:iterator&gt; 3. set标签&lt;s:set&gt;标签用于将数据存储到指定的位置，存储数据的位置包括application、session、request、page、action一共5个位置。&lt;s:set&gt;的属性： value：必选，存储到map的值，是一个OGNL表达式； var：可选，存储到map的键； scope：可选，存储范围，不写默认是action，在contextMap中和request中各存一份； 1234567891011&lt;s:set value="'zhuobo-action'" var="username"/&gt;&lt;s:set value="'zhuobo-application'" var="username" scope="application"/&gt;&lt;s:set value="'zhuobo-request'" var="username" scope="request"/&gt;&lt;s:set value="'zhuobo-session'" var="username" scope="session"/&gt;&lt;s:set value="'zhuobo-page'" var="username" scope="page"/&gt;&lt;%--取数据--%&gt;&lt;s:property value="#application.username"/&gt;&lt;br&gt;&lt;s:property value="#request.username"/&gt;&lt;br&gt;&lt;s:property value="#session.username"/&gt;&lt;br&gt;&lt;s:property value="#username"/&gt;&lt;br&gt; 4. action标签action标签用于在jsp页面中调用Action，如果需要将Action的结果页面展示出来，设置属性 executeResult为 true，指定Action的name属性，但是不用写后缀名。 1&lt;s:action name="hello" executeResult="true" /&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2的contextMap]]></title>
    <url>%2F2019%2F06%2F06%2Fstruts2%E7%9A%84contextMap%2F</url>
    <content type="text"><![CDATA[一、Action的生命周期1. Action是多例的struts2的Action的多实例的，也就是每次被访问都会创建一个实例（也就是为每个请求都创建一个实例），因此不会出现线程安全问题。与之对比的是Servlet和struts1的Action都是单实例的，当有不同的请求同时访问，可能会出现线程安全问题。为了验证struts2为每次请求都创建一个Action的实例，下面创建一个Action，访问并在方法中打印this（this值得就是这个Action对象本身）。 123456public class HelloAction extends ActionSupport &#123; public String sayHello() &#123; System.out.println(this); return SUCCESS; &#125;&#125; 输出： 这个在一个浏览器中刷新几次访问HelloAction得到的结果，由于this表示的就是Action对象本身，从输出结果可以知道这些对象是不同的对象，因此struts2的Action每次被访问都会实例化。 2. Servlet是单例的与struts2的Action不同，Servlet是默认情况下单例的。当有多个请求请求同一个Servlet的时候，Servlet采用多线程的方式处理多个请求。多线程依赖线程池实现，Servlet使用一个调度线程管理多个处理请求的线程。当有一个请求到来，调度线程为这个请求分配一个处理请求的线程，然后由该线程执行Servlet的service方法。因此，当有多个请求到达服务器，就会出现service方法在多个线程之间并发执行的情况。这种单实例多线程的机制有利于减少创建实例带来的开销，提升了对请求的响应时间，但是有可能会出现线程安全问题。 与此类似的，struts1的Action也是单例的。 线程安全问题的避免： 同步对共享数据的访问：在doGet()，doPost()方法前加上关键字 synchronized，可以保证一次（同时）只能有一个线程在访问共享区域； 避免使用Servlet的成员变量，使用局部变量，哪怕不得已使用了成员变量，也不要改变成员变量的值，获取它即可。 二、请求数据的存储每次向服务器发起请求都会携带一些请求的数据，那么服务器是如何存储这些请求的数据的呢？当服务器接收到请求，在执行Action之前核心控制器 StrutsPrepareAndExecuteFilter 都会创建一个ActionContext和一个ValueStack用于存储数据，这两个对象存储了整个访问过程的数据。 ValueStack对象是一个List对象，封装了当前被访问的Action的对象以及其他的相关的对象； ActionContext对象，也就是contextMap对象，是一个Map对象，存储的数据包括： Key Value 说明 valueStack (root) java.util.List 没有root这个key，值栈是是一个list。 application java.util.Map&lt;String,Object&gt; ServletContext中的所有属性。 session java.util.Map&lt;String,Object&gt; HttpSession中的所有属性。 request java.util.Map&lt;String,Object&gt; ServletRequest中的所有属性。 parameters java.util.Map 参数 attr java.util.Map 把页面、请求、会话、应用范围内的所有属性放到一起。 可以使用&lt;s:debug&gt;标签查看ActionContext存储的数据。 由上面的表格可以知道session也是保存在contextMap中的，因此我们可以测试一下，先往session中存储一个键值对： 1234&lt;body&gt; &lt;%session.setAttribute("username","david");%&gt; &lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt; 三、ActionContext的数据操作1. ActionContext（contextMap）中存储数据1234567891011121314151617181920212223242526272829303132public class HelloAction extends ActionSupport &#123; public String sayHello() &#123; System.out.println(this); // 1. 获取ActionContext ActionContext contextMap = ActionContext.getContext(); // 2. 往ActionContext中存储数据（键值对） contextMap.put("username","zhuobo"); contextMap.put("password", "abc"); // 3. 往ActionContext中的session中存储数据 Map&lt;String, Object&gt; session = contextMap.getSession(); session.put("username", "zhuobo11"); session.put("password", "abc11"); // 4. 往ActionContext中的request中存储数据 Map&lt;String, Object&gt; application = contextMap.getApplication(); //session对象也可以用这种方法获取 /*HttpSession session1 = ServletActionContext.getRequest().getSession();*/ application.put("username", "zhuobo22"); application.put("password", "abc22"); // 5. 往request中存储数据 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute("username","zhuobo33"); request.setAttribute("password", "abc33"); return SUCCESS; &#125;&#125; 2. ValueStack中存储数据ValueStack是存储在request域中，也存储在ActionContext的，因此可以有3种方式获取ValueStack。一是通过ActionContext获取，二是通过Request获取，而获取 Request又有两种方式。在这三种方式中，第一种最常用，因为比较简便。 1234567891011121314151617181920// 获取ValueStack的三种方式,但是由于每次访问都是仅仅创建一个ActionContext和ValueStack，// 因此三种方法获取的都是同一个ValueStack// 1.通过ActionContext获取ValueStack valueStack1 = ActionContext.getContext().getValueStack();// 2.先获取Request，再通过request获取ValueStackMap&lt;String, Object&gt; request = (Map&lt;String, Object&gt;) ActionContext.getContext().get("request");ValueStack valueStack2 = (ValueStack) request.get("struts.valueStack");// 3. 先获取Request对象，再获取ValueStackValueStack valueStack3 = (ValueStack) ServletActionContext.getRequest().getAttribute("struts.valueStack");// 向ValueStack中存储数据（对象）valueStack1.push(new User("zhuobo","abc "));System.out.println(valueStack1);System.out.println(valueStack2);System.out.println(valueStack3); 三种不同方式获取的值栈是同一个值栈： 使用ValueStack的push方法往 ValueStack中存储数据。 3. 获取数据在jsp页面，通过struts的 &lt;s:property value=&quot;&quot;&gt;获取，双引号里写的是OGNL。其中如果是存储在contextMap中的属性，获取的时候加#，存储在ValueStack中的直接写key。当有多个同名的属性都存储在ValueStack中时，可以使用索引来获取，[i].xxx表示获取低i个xxx属性的值。特殊的当获取值栈的属性，而没有写value值的时候，比如 &lt;s:property /&gt;表示获取值栈栈顶的对象。 123456789101112&lt;%--获取contextMap的属性，需要加#--%&gt;获取ContextMap的属性&lt;s:property value="#username" /&gt; &lt;br&gt;获取session的属性&lt;s:property value="#session.username" /&gt; &lt;br&gt;获取request的属性&lt;s:property value="#request.username" /&gt; &lt;br&gt;获取application的属性&lt;s:property value="#application.username" /&gt; &lt;br&gt;&lt;%--获取值栈的属性--%&gt;获取值栈的属性&lt;s:property value="[0].username"/&gt;&lt;br&gt;&lt;s:property value="[1].username"/&gt;&lt;br&gt;&lt;s:property /&gt;&lt;s:debug&gt;&lt;/s:debug&gt; &lt;br&gt; 4. ValueStack的方法 push()：往值栈的栈顶中压入数据 12// 向ValueStack中存储数据（对象）valueStack1.push(new User("zhuobo-值栈中的user对象的属性","abc")); setValue(String，Object)：更改栈顶的值 123456789// 更改栈顶的username为tzhuobovalueStack1.setValue("username","tzhuobo");// 如果栈顶没有usernamehehe属性，或者没有提供setter方法，就会报错valueStack1.setValue("usernamehehe", "tzhuobo");// 如果键名前面加了#，表明向contextMap中存储值valueStack1.setValue("#usernamehehe", "tzhuobohehe"); 没有提供setter方法，报错信息： 如果键名前面加了#，表明向contextMap中存储值： set()：把数据存储到一个Map中，然后将Map压如值栈 12// set方法，将数据存储进一个map，然后将map压入值栈valueStack1.set("user", new User("david","123")); 获取map中的值： 123&lt;%--存储的键名是user,点运算符得到user的username--%&gt;&lt;s:property value="user.username"/&gt;&lt;s:property value="user.password"/&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2的OGNL]]></title>
    <url>%2F2019%2F06%2F06%2Fstruts2%E7%9A%84OGNL%2F</url>
    <content type="text"><![CDATA[一、OGNL介绍OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，是一个单独的开源项目。Struts2框架使用OGNL作为默认的表达式语言，作用类似于EL表达式，可以从作用域中获取值；Struts2框架中想要使用OGNL表单时就必须使用struts2标签库。 二、OGNL的功能1. 访问对象的方法比如字符串对象的方法 1&lt;s:property value="'david'.length()" /&gt;&lt;br&gt; 2. 访问静态属性struts2默认是不允许OGNL访问类的静态属性和静态方法的，在 default.properties中可以看到 struts.ognl.allowStaticMethodAccess=false，因此要访问类的静态属性和静态方法要在 struts.xml配置为true 1&lt;constant name="struts.ognl.allowStaticMethodAccess" value="true" /&gt; 访问静态属性的格式是 @类名@方法： 12int的最大值&lt;s:property value="@java.lang.Integer@MAX_VALUE" /&gt; &lt;br&gt; 随机数&lt;s:property value="@java.lang.Math@abs(-3)" /&gt; &lt;br&gt; 3. 封装list数据1&lt;s:radio list="&#123;'男', '女'&#125;" name="gender" label="性别" /&gt; 解析为HTML，将list的值作为value： 4. 封装map数据1&lt;s:radio list="#&#123;'male':'男','female':'女'&#125;" label="性别" name="gender" /&gt; 解析为HTML，将map的key作为value 5 .在struts.xml中使用OGNL可以中struts.xml中使用OGNL获取Action的值，比如在Action中有个属性，并且该属性提供了getter方法，可以使用OGNL去获取该属性的值。在struts的文件下载中，为了下载的文件中文名可以不乱码，在Action的方法中使用URLEncoder类的静态方法encode给中文名的文件名编码，并且在struts.xml中通过 &lt;param name=&quot;contentDisposition&quot;&gt;attachment;filename=${filename}&lt;/param&gt;的方法获取文件名。现在通过OGNL表达式不用在Action中使用URLEncoder的方法编码，在struts.xml中也可实现。 1234567&lt;action name="download" class="cn.zhuobo.web.action.DownloadAction" method="download"&gt; &lt;result type="stream" name="success"&gt; &lt;param name="inputStream"&gt;inputstream&lt;/param&gt; &lt;param name="contentDisposition"&gt;attachment;filename=$&#123;@java.net.URLEncoder@encode(filename, "utf-8")&#125;&lt;/param&gt; &lt;param name="contentType"&gt;application/octet-stream&lt;/param&gt; &lt;/result&gt;&lt;/action&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2文件上传]]></title>
    <url>%2F2019%2F06%2F05%2Fstruts2%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[一、文件上传 struts提供的标签&lt;s:file&gt;支持文件的上传，该标签叫文件选择域； 这个标签和HTML标签&lt;input file&gt;的作用是一样的； 文件上传有两个前提条件： 表单的请求方式为POST； enctype类型必须为multipart/form-data; 二、简单的文件上传 upload.jsp 123456789&lt;body&gt; 上传文件&lt;s:form action="/upload" method="POST" enctype="multipart/form-data"&gt; &lt;s:textfield name="username" label="用户名" /&gt; &lt;s:textfield name="password" label="密码" /&gt; &lt;s:file name="file" label="文件" /&gt; &lt;s:submit value="上传" /&gt;&lt;/s:form&gt;&lt;/body&gt; UploadAction.java 123456789101112131415161718192021222324252627282930313233public class UploadAction extends ActionSupport &#123; private String username; private String password; private File file; // 临时文件 private String fileContentType;// 文件的类型,固定的写法 private String fileFileName; // 文件名,固定的写法 // 5个属性全部写上setter方法，为了可以自动注入参数 public String upload() &#123; System.out.println(username); System.out.println(password); System.out.println(file); System.out.println(fileFileName); System.out.println(fileContentType); // 1. 保存文件的目录 String dir = ServletActionContext.getServletContext().getRealPath("/WEB-INF/upload") + "\\" + username; System.out.println("保存文件的目录：" + dir); File f = new File(dir); if (!f.exists()) &#123; f.mkdirs(); &#125; // 2. 保存路径 + 文件名 String fileSavePath = dir + "\\" + fileFileName; // 3. 文件剪切到指定的目录 file.renameTo(new File(fileSavePath)); return SUCCESS; &#125;&#125; struts.xml 12345678&lt;package name="p1" extends="struts-default"&gt; &lt;action name="upload" class="cn.zhuobo.web.action.UploadAction" method="upload"&gt; &lt;!--上传失败，回到upload.jsp--&gt; &lt;result name="input"&gt;/upload.jsp&lt;/result&gt; &lt;!--上传成功，转发到success.jsp--&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 三、文件上传的配置1. 文件的大小struts在默认情况下只能上传大小不超过2MB的文件，而且如果上传的文件大小超过2MB，便会报错，要求提供name为input的回显结果。对文件类型的限制都是在一个文件上传拦截器FileUploadInterceptor中实现的。 在struts.xml修改文件上传大小的限制，配置一个常量，修改default.properties的值: 12&lt;!--限制文件上传的大小为10M--&gt;&lt;constant name="struts.multipart.maxSize" value="10240000" /&gt; 2. 文件的类型通过拦截器限制文件上传的MIME类型、或者文件的扩展名。 配置默认拦截器组defaultStack中的fileUpload拦截器，有两种方式，一是配置允许的文件MIME类型，而是配置允许的文件扩展名。 12345678910111213141516&lt;package name="p1" extends="struts-default"&gt; &lt;action name="upload" class="cn.zhuobo.web.action.UploadAction" method="upload"&gt; &lt;!--默认拦截器，默认拦截器是一组拦截器--&gt; &lt;interceptor-ref name="defaultStack"&gt; &lt;!--&lt;param name="fileUpload.allowedExtensions"&gt;jpg,png&lt;/param&gt;--&gt; &lt;param name="fileUpload.allowedTypes"&gt;image/jpeg,image/png,image/bmp&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;!--上传失败，回到upload.jsp--&gt; &lt;result name="input"&gt;/upload.jsp&lt;/result&gt; &lt;!--上传成功，转发到success.jsp--&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 3. 修改错误信息为中文struts对于不符合要求的文件会有错误信息，但是是英文显示的，现在希望可以友好地展示错误信息。 在src下出创建一个国际化的资源包，名为fileUploadMessage.properties,文件内容为： 12345struts.messages.error.uploading=Error uploading: &#123;0&#125;struts.messages.error.file.too.large=&#123;1&#125;: 文件大小超过10Mstruts.messages.error.content.type.not.allowed=&#123;1&#125;：文件的类型不被允许-&#123;3&#125;struts.messages.error.file.extension.not.allowed=&#123;1&#125;：文件的扩展名不被允许-&#123;3&#125;struts.messages.upload.error.SizeLimitExceededException=文件大小限制! 最大是: &#123;0&#125; bytes.但是上传的是: &#123;1&#125; bytes! 在struts.xml中指定国际化资源包 1&lt;constant name="struts.custom.i18n.resources" value="fileUploadMessage" /&gt; 四、多文件的上传要上传多个文件，关键点在于可以接收处理多个文件，因此Action中将接收的文件字段改为数组，遍历处理文件数组即可。 upload.jsp 123456789101112&lt;body&gt; 上传文件 &lt;s:actionerror /&gt; &lt;s:form action="/upload" method="POST" enctype="multipart/form-data"&gt; &lt;s:textfield name="username" label="用户名" /&gt; &lt;s:textfield name="password" label="密码" /&gt; &lt;s:file name="files" label="文件" /&gt; &lt;s:file name="files" label="文件" /&gt; &lt;s:file name="files" label="文件" /&gt; &lt;s:submit value="上传" /&gt; &lt;/s:form&gt;&lt;/body&gt; UploadAction.java 123456789101112131415161718192021222324252627282930313233343536public class UploadAction extends ActionSupport &#123; private String username; private String password; private File[] files; private String[] filesContentType; private String[] filesFileName; // 这里省略了属性的setter方法... //文件上传 public String upload() &#123; // 1. 保存的目录 String dir = ServletActionContext.getServletContext().getRealPath("/WEB-INF/upload") + "\\" + username; System.out.println("保存文件的路径：" + dir); File f = new File(dir); if (!f.exists()) &#123; f.mkdirs(); &#125; // 2. 遍历文件的数组 for (int i = 0; i &lt; files.length; i++) &#123; File file = files[i]; String fileName = filesFileName[i]; String fileType = filesContentType[i]; System.out.println(fileName + ":" + fileType); // 3. 保存文件的路径 String saveFilePath = dir + "\\" + fileName; // 4. 剪切文件到改路径 file.renameTo(new File(saveFilePath)); &#125; return SUCCESS; &#125;&#125; 五、文件的下载DownloadAction.java Action提供一个属性InputStream; Action提供为属性 Inputstream提供一个getter方法; 为属性 InputStream 赋值; 123456789101112131415161718192021222324252627282930public class DownloadAction extends ActionSupport &#123; private InputStream inputStream; private String filename; public String getFilename() &#123; return filename; &#125; public InputStream getInputStream() &#123; return inputStream; &#125; public String download() throws FileNotFoundException, UnsupportedEncodingException &#123; filename = "1.jpg"; String path = "C:\\Users\\zhuobo\\Pictures\\" + filename; // 给inputStream赋值 inputStream = new FileInputStream(path); // 指定被下载的文件命名为 猪八戒.jpg filename = "猪八戒.jpg"; // 有中文名，使用utf-8编码 filename = URLEncoder.encode(filename, "utf-8"); System.out.println(filename); return SUCCESS; &#125;&#125; struts.xml 配置一个结果视图，type为stream 为结果视图配置参数 指定输入流、文件名 1234567891011&lt;action name="download" class="cn.zhuobo.web.action.DownloadAction" method="download"&gt; &lt;result type="stream" name="success"&gt; &lt;!--表示读取的是getInputStream方法 --&gt; &lt;param name="inputStream"&gt;inputstream&lt;/param&gt; &lt;!--$&#123;filename&#125;表示读取的是getFileName方法,也就是指定的被下载的文件的命名--&gt; &lt;param name="contentDisposition"&gt;attachment;filename=$&#123;filename&#125;&lt;/param&gt; &lt;param name="contentType"&gt;application/octet-stream&lt;/param&gt; &lt;/result&gt;&lt;/action&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2拦截器]]></title>
    <url>%2F2019%2F06%2F04%2Fstruts2%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、struts2拦截器介绍struts2的许多功能都是建立在拦截器之上的，比如国际化、转换器、校验等功能。拦截器是动态拦截Action调用的对象，它提供了一种可以使开发者定义在一个Action执行前后执行的代码，也可以在Action执行前阻止其执行。拦截器栈（Interceptor stack），或者说拦截器链（Interceptor China）就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 struts2的默认拦截器在配置文件 struts-default.xml中配置。拦截器是AOP编程思想的一种应用的形式。 当请求到达Struts 2的ServletDispatcher时，Struts 2会查找配置文件，并根据其配置实例化相对的拦截器对象，然后串成一个列表（list），最后一个一个地调用列表中的拦截器。拦截器链在执行Action前顺序执行，执行Action后倒序执行。 拦截器Interceptor的类的继承、实现结构: 二、自定义拦截器 写一个类继承 AbstractInterceptor类，复写方法 intercept，参数 ActionInvocation对象调用方法 invoke表示放行，invoke方法返回值是字符串 &quot;success&quot;。 12345678910public class MyInterceptor extends AbstractInterceptor &#123; @Override public String intercept(ActionInvocation actionInvocation) throws Exception &#123; System.out.println("拦截之前前前"); // 放行 String returnStr = actionInvocation.invoke(); System.out.println("拦截之后后后"); return returnStr; &#125;&#125; 在 struts.xml为Action配置一个拦截器 1234567891011&lt;package name="interceptor_p" extends="struts-default"&gt; &lt;interceptors&gt; &lt;interceptor name="interceptor" class="cn.zhuobo.web.interceptor.MyInterceptor" /&gt; &lt;/interceptors&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction" method="sayHello"&gt; &lt;!-- 拦截器的引用，name是上面配置的拦截器 --&gt; &lt;interceptor-ref name="interceptor"&gt;&lt;/interceptor-ref&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 注意: 如果在struts.xml中的 action标签中配置了拦截器的引用，那么默认的拦截器就失效了，也就是之前使用的参数注入等拦截器失效了。 拦截器的执行顺序，假设有两个拦截器，如下： MyInterceptor1： 123sout("拦截器11前前");invoke();sout("拦截器11后后"); MyInterceptor2： 123sout("拦截器22前前");invoke();sout("拦截器22后后"); 打印结果： 12345拦截器11前前拦截器22前前Action执行拦截器22后后拦截器11后后 事实上 invoke方法的调用代表两种含义： 一是如果拦截器栈中还有其他的拦截器，那么 ActionInvocation.invoke() 将调用栈中的下一个拦截器来执行； 二是如果拦截器栈中没有其他拦截器了，那么 ActionInvocation.invoke() 将调用Action来执行。 在这种情况下，如果不是调用invoke方法，而是直接返回一个其他的什么字符串，就会导致整个执行的过程被终止；这种以 ActionInvocation.invoke() 为界的机制，事实上可以将拦截器中的代码分为两个部分，在invoke方法之前的代码将会在Action之前执行，invoke方法之后的代码将会在Action执行之后逆序执行。 三、拦截器的一个应用实例：登录验证实现的功能：用户必须提供指定的用户名密码登录才可以访问到非登录页面的内容，如果直接访问非登录页面会直接跳转到登录页面。 1. 页面代码逻辑： 用户在登录页面，填写数据提交到UserAction的login方法，login方法判断是否为指定的用户名密码，如果是，就跳转到main.jsp，否则跳转到login.jsp； 在main.jsp提供连个连接，分别是学生列表、老师列表，点击分别跳转到学生列表、老师列表页面； 如果没有登录，直接访问学生列表，老师列表会不被允许，直接跳转到login.jsp login.jsp 12345678&lt;body&gt;登录&lt;form action="$&#123;pageContext.request.contextPath&#125;/login"&gt; 用户名：&lt;input name="username" type="text"&gt; 密 码：&lt;input name="password" type="text"&gt; &lt;input value="登录" type="submit"&gt;&lt;/form&gt;&lt;/body&gt; main.jsp 123456主页&lt;ul&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/student/list"&gt;学生列表&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="$&#123;pageContext.request.contextPath&#125;/teacher/list"&gt;老师列表&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; studentList.jsp 12345学生列表&lt;ul&gt; &lt;li&gt;孙无用&lt;/li&gt; &lt;li&gt;李无极&lt;/li&gt;&lt;/ul&gt; teacherList.jsp 1234567&lt;body&gt;老师列表&lt;ul&gt; &lt;li&gt;王老师&lt;/li&gt; &lt;li&gt;朱老师&lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 2. 拦截器、struts.xml配置UserAction.java 12345678910111213141516171819public class UserAction extends ActionSupport implements ModelDriven&lt;User&gt; &#123; private User user = new User(); public String login() &#123; if ("zhuobo".equals(user.getUsername()) &amp;&amp; "abc".equals(user.getPassword())) &#123; // 登录，将user存储到session HttpSession session = ServletActionContext.getRequest().getSession(); session.setAttribute("user", user); return SUCCESS; &#125; // 如果没有登录，跳转到toLoginPage的一个结果视图，这是一个全局的结果视图 return "toLoginPage"; &#125; @Override public User getModel() &#123; return user; &#125;&#125; CheckLoginInterceptor.java 这个拦截器是关键，该拦截器的逻辑是，从session中查询是否有user，如果没有user就说明没有登录，直接跳转到一个toLoginPage的全局的结果视图（该视图与Action无关，谁都可以跳转到，不和Action绑定）。 123456789101112131415public class CheckLoingInterceptor extends AbstractInterceptor&#123; @Override public String intercept(ActionInvocation actionInvocation) throws Exception &#123; // 判断是否登录 HttpSession session = ServletActionContext.getRequest().getSession(); User user = (User) session.getAttribute("user"); if (user != null) &#123; return actionInvocation.invoke(); &#125; return "toLoginPage"; &#125;&#125; struts.xml 配置的逻辑：用户的任何请求，除了login之外，都应该被CheckLoginInterceptor所拦截，判断是否已经登录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;struts&gt; &lt;!--这个一个抽象的包，用来给后面的包继承，在包里定义的判断是否登录的拦截器、默认的拦截器（参数注入等功能）--&gt; &lt;package name="p1" extends="struts-default" abstract="true"&gt; &lt;interceptors&gt; &lt;!--判断登录的拦截器--&gt; &lt;interceptor name="interceptor" class="cn.zhuobo.web.interceptor.CheckLoingInterceptor" /&gt; &lt;!--一个拦截器分组，包括了自定义的拦截器，默认拦截器--&gt; &lt;interceptor-stack name="myDefaultStack"&gt; &lt;interceptor-ref name="defaultStack" /&gt; &lt;interceptor-ref name="interceptor" /&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!--全局的结果视图，该视图和Action无关，不和Action绑定--&gt; &lt;global-results&gt; &lt;result name="toLoginPage"&gt;/login.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;/package&gt; &lt;!--登录login--&gt; &lt;package name="p2" extends="p1"&gt; &lt;action name="login" class="cn.zhuobo.web.action.UserAction" method="login"&gt; &lt;!--这个是登录，不需要拦截，由于有了自定义的拦截器（默认拦截器失效），因此要指定默认拦截器，登录不需要校验是否登录--&gt; &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; &lt;result name="success"&gt;/WEB-INF/main.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;!--查看学生列表--&gt; &lt;package name="p3" extends="p1" namespace="/student"&gt; &lt;action name="list" class="cn.zhuobo.web.action.StudentAction" method="list"&gt; &lt;!--这里要判短是否登录，配置自定义拦截器分组，包括校验登录拦截器、默认拦截器--&gt; &lt;interceptor-ref name="myDefaultStack"&gt;&lt;/interceptor-ref&gt; &lt;result name="success"&gt;/WEB-INF/studentList.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; &lt;!--查看老师列表--&gt; &lt;package name="p4" extends="p1" namespace="/teacher"&gt; &lt;action name="list" class="cn.zhuobo.web.action.TeacherAction" method="list"&gt; &lt;!--这里要判短是否登录，配置自定义拦截器分组，包括校验登录拦截器、默认拦截器--&gt; &lt;interceptor-ref name="myDefaultStack"&gt;&lt;/interceptor-ref&gt; &lt;result name="success"&gt;/WEB-INF/teacherList.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2国际化]]></title>
    <url>%2F2019%2F06%2F03%2Fstruts2%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、软件的国际化为了使不同国家和地区的人可以使用到使用该地区的网站、应用，网站必须适配不同国家和地区的语言，而且还要使软件的开发与特定的语言脱钩。也就是说不能专门为了适配中文写一个软件、适配英文再写一个软件、适配繁体字也写一个软件，做到当软件在不通的国家和地区被使用就可以不必更改代码就可以适应该地区的语言。 苹果官网为不同的地区适配了不同的语言。 二、读取国际化数据1. 创建国际化的资源数据在src目录下创建resources资源目录，在resources目录里创建创建国际化资源数据，命名的方法为xxx_语言_地区.properties。比如可以创建中国大陆的国际化数据，资源文件名为message_zh_CN.properties，创建美国的国际化资源数据message_en_US.properties。资源文件的内容如下，就可以实现访问同一个注册页面，当用户在美国注册页面显示中文，在中国大陆注册显示简体中文。 2. java中读取国际化的数据12345678910111213141516171819202122232425262728@Testpublic void test1() &#123; //读取国际化的资源数据 // 使用ResourceBundle读取国际化的数据，这是读取默认的语言 //ResourceBundle rb = ResourceBundle.getBundle("resources.message"); //读取指定的地区的语言的数据 //ResourceBundle rb = ResourceBundle.getBundle("resources.message", Locale.US); /* USERNAEM PASSWORD REPASSWORD SUBMIT */ ResourceBundle rb = ResourceBundle.getBundle("resources.message", Locale.CHINA); /* 用户名 密码 确认密码 提交 */ System.out.println(rb.getString("login.username")); System.out.println(rb.getString("login.password")); System.out.println(rb.getString("login.repassword")); System.out.println(rb.getString("login.submit"));&#125; 3. 在jsp中读取国际化的数据和java中类似的，只是中jsp标签之中写java代码，当然jsp本质上就是java。 4. 在jstl中读取国际化的数据三、struts国际化的实现步骤1. 配置资源包 配置全局的资源包 在src目录下创建resources资源目录，在resources目录里创建创建国际化资源数据，命名的方法为xxx_语言_地区.properties。这种方法创建的资源包就是全局资源包。要在struts.xml中配置。指定国际化数据的资源包，全局的资源包的意思就是指任何一个jsp页面访问的数据都是这个资源包下的数据； 1&lt;constant name="struts.custom.i18n.resources" value="resources.message"&gt;&lt;/constant&gt; 配置包范围的资源包 在web包下配置包范围的资源包，资源包的命名规范是 package_语言代码_地区代码.properties，资源包内容还是一样，在web包下配置这种资源包，表示该资源包可以被web下的Action访问，这种资源包的访问优先级高于全局消息资源包，也就是说如果配置了包范围的资源包，有限访问包范围的资源包，没有便访问全局消息资源包。 配置局部消息资源包 在action包下配置资源文件，命名规则为 Action类名_语言代码_地区代码.properties，表示该资源包只能被指定的Action类访问，文件内容还是一致的，这个资源包的优先级是三者中最高。如命名为 UserAction_zh_CN.properties。 再次总结一下，这种中资源包的范围由大到小，优先级由低到高，也就是优先级采取就近原则。 2. 读取资源包数据 使用struts的text标签获取国际化资源包的内容 123456&lt;form&gt; &lt;s:text name="login.username" /&gt;&lt;input type="text" name="username"&gt;&lt;br&gt; &lt;s:text name="login.password" /&gt;&lt;input type="text" name="password"&gt;&lt;br&gt; &lt;s:text name="login.repassword" /&gt;&lt;input type="text" name="repassword"&gt;&lt;br&gt; &lt;input type="submit" value="&lt;s:text name='login.submit' /&gt;"&gt;&lt;/form&gt; 访问该注册页面，会根据浏览器的语言版本读取到不同的数据。 中文版的Chrome： 英文版的Firefox： 在Action中读取资源包的内容 ActionSupport类提供了一个 getText()方法用来获取资源数据，也就是Action必须继承ActionSupport类，这种获取方法在开发中几乎不用。 123456789101112131415public class HelloAction extends ActionSupport &#123; public String sayHello() &#123; System.out.println("hello"); System.out.println(getText("login.username")); System.out.println(getText("login.password")); System.out.println(getText("login.submit")); return NONE; /* hello USERNAME-P PASSWORD-P SUBMIT-P */ &#125;&#125; 指定要读取的资源包，可以使用 s:i18n标签指定要读取的国际化资源包文件。如下，指定读取包范围的资源包。 12345678&lt;form&gt; &lt;s:i18n name="cn.zhuobo.web.package"&gt; &lt;s:text name="login.username" /&gt;&lt;input type="text" name="username"&gt;&lt;br&gt; &lt;s:text name="login.password" /&gt;&lt;input type="text" name="password"&gt;&lt;br&gt; &lt;s:text name="login.repassword" /&gt;&lt;input type="text" name="repassword"&gt;&lt;br&gt; &lt;input type="submit" value="&lt;s:text name='login.submit' /&gt;"&gt; &lt;/s:i18n&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2表单校验]]></title>
    <url>%2F2019%2F06%2F02%2Fstruts2%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[一、struts的表单标签 在jsp页面引入struts标签 1&lt;%@ taglib uri="/struts-tags" prefix="s"%&gt; 使用form标签 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;title&gt;register&lt;/title&gt; &lt;s:head&gt;&lt;/s:head&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action="user/register.do"&gt; &lt;s:textfield name="username" label="用户名" requiredLabel="true" requiredPosition="left"&gt;&lt;/s:textfield&gt; &lt;s:password name="password" label="密码" requiredLabel="true" requiredPosition="left"&gt;&lt;/s:password&gt; &lt;s:textfield name="birthday" label="生日"&gt;&lt;/s:textfield&gt; &lt;s:checkboxlist list="#&#123;'篮球':'篮球','足球':'足球','泡妞':'泡妞'&#125;" name="hobby" label="爱好"&gt;&lt;/s:checkboxlist&gt; &lt;s:radio list="#&#123;'true':'已婚', 'false':'未婚'&#125;" name="married" label="是否已婚"&gt;&lt;/s:radio&gt; &lt;s:submit value="注册"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; 显示效果如下： struts表单的优点： 自带了一定了样式，比如对齐 方便标记字段是否为必须填写 方便数据的回显 方便显示校验的信息 二、struts的表单在Action校验 在提交表单的Action（继承了ActionSupport类）的覆盖重写方法validate,这是一个全局的方法,也就是在该Action里的任何方法要执行，就要首先执行这个 validate方法。 1234567891011@Overridepublic void validate() &#123; if (StringUtils.isEmpty(user.getUsername())) &#123; addFieldError("username", "用户名不能为空"); &#125; // 相当于if(user.getPassword() == null || "".equals(user.getPassword())) // 这个工具类封装了这一行代码...... if (StringUtils.isEmpty(user.getPassword())) &#123; addFieldError("password", "密码不能为空"); &#125;&#125; 由于validate方法是一个全局的方法，因此Action里所有的方法执行之前都会先执行该方法，但是如果是这样又有着明显的不合理，总能不能什么方法都要执行校验用户名、密码的逻辑。因此可以在不需要执行validate方法的方法上加上注解@SkipValidation，表示该方法跳过跳过validate方法的验证。 1234@SkipValidationpublic String list() &#123; return "list";&#125; 如果输入用户名密码为空，就会提示： 此外还可以为每个方法写一个验证的方法，这种就是局部的验证方法，方法命名为 validate方法名(方法名首字符大写)，如有一个list方法，那么就写一个validateList方法专门验证list方法 123456789101112131415161718// 专门验证register方法的validate方法 public void validateRegister() &#123; if (StringUtils.isEmpty(user.getUsername())) &#123; addFieldError("username", "用户名不能为空"); &#125; if (StringUtils.isEmpty(user.getPassword())) &#123; addFieldError("password", "密码不能为空"); &#125; &#125; public String register() &#123; System.out.println(user); //调用service注册 userService.register(user); return NONE; &#125; 三、xml配置校验在action里为某个Action类写一个配置文件，表示该Action的所有方法都要进行校验，如Action的名为UserAction，则xml的命名为UserAction-validation.xml，该文件的配置为 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 该dtd在xwork-core-2.3.37.jar--&gt;&lt;!DOCTYPE validators PUBLIC "-//Apache Struts//XWork Validator 1.0.3//EN" "http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd"&gt;&lt;validators&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;username&lt;/param&gt; &lt;message&gt;用户名不能为空-xml&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 这种方式的配置也是全局的配置，默认Action的每个方法都要执行校验，同时，如果有某些方法不希望执行校验在方法上加上注解 @SkipValidation即可跳过校验。 当然，也可以为类的某个方法指定校验，这时候xml文件的命名改为 Action类名-方法名-validation.xml，比如可以命名为 UserAction-register-validation.xml。 1234567891011121314&lt;validators&gt; &lt;!--用户名不能为空--&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;username&lt;/param&gt; &lt;message&gt;用户名不能为空-xml&lt;/message&gt; &lt;/validator&gt; &lt;!-- 密码长度至少为8 --&gt; &lt;validator type="stringlength"&gt; &lt;param name="fieldName"&gt;password&lt;/param&gt; &lt;param name="minLength"&gt;8&lt;/param&gt; &lt;message&gt;密码长度至少为8&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 四、采用xml校验一般来说会采用xml的方式校验表单，以减少Action中的代码量。这里是xml校验的几个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;validators&gt; &lt;!--username--&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;username&lt;/param&gt; &lt;message&gt;用户名不能为空&lt;/message&gt; &lt;/validator&gt; &lt;!--age--&gt; &lt;validator type="int"&gt; &lt;param name="fieldName"&gt;age&lt;/param&gt; &lt;param name="max"&gt;100&lt;/param&gt; &lt;param name="min"&gt;10&lt;/param&gt; &lt;message&gt;年龄必须是10~100&lt;/message&gt; &lt;/validator&gt; &lt;!--email使用两种校验，一是不能为空，而是如果填写了就校验格式--&gt; &lt;!--1. 邮箱不能为空--&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;email&lt;/param&gt; &lt;message&gt;邮箱不能为空&lt;/message&gt; &lt;/validator&gt; &lt;!-- 2. 邮箱格式 --&gt; &lt;validator type="email"&gt; &lt;param name="fieldName"&gt;email&lt;/param&gt; &lt;message&gt;邮箱格式不正确&lt;/message&gt; &lt;/validator&gt; &lt;!-- password--&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;password&lt;/param&gt; &lt;message&gt;邮箱不能为空&lt;/message&gt; &lt;/validator&gt; &lt;validator type="stringlength"&gt; &lt;param name="fieldName"&gt;password&lt;/param&gt; &lt;param name="minLength"&gt;8&lt;/param&gt; &lt;param name="maxLength"&gt;18&lt;/param&gt; &lt;message&gt;密码长度为8~18&lt;/message&gt; &lt;/validator&gt; &lt;!--确认密码 要和password一致--&gt; &lt;validator type="expression"&gt; &lt;param name="expression"&gt; &lt;![CDATA[password == repassword]]&gt; &lt;/param&gt; &lt;message&gt;密码不一致&lt;/message&gt; &lt;/validator&gt; &lt;validator type="url"&gt; &lt;param name="fieldName"&gt;url&lt;/param&gt; &lt;message&gt;url不合法，以http://开头&lt;/message&gt; &lt;/validator&gt; &lt;validator type="required"&gt; &lt;param name="fieldName"&gt;gender&lt;/param&gt; &lt;message&gt;性别必须选择&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts问题总结]]></title>
    <url>%2F2019%2F05%2F31%2Fstruts%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在使用struts2框架的过程中遇到的一些问题的总结： 1. 异常Error setting expression ‘xxx’ with value… 在提交表单的时候遇到的这个问题，其实并不影响应用的运行，但是也还是个异常，根据提示可以发现是 Developer Notification，也就是在struts.xml配置了开发模式，才会提醒这个信息，关闭开发模式便不会提醒。但是问题的根本应该是表单对应的参数，比如username和password在Action类里没有提供对应的setter和getter方法，在Action类中提供了便不会有这个异常的提示。 2. struts2的自动类型转换Servlet接收到的表单提交的数据都是字符串String类型的，但是Struts2会自动进行类型转换，比如可以转为Date类型、boolean类型，如果是CheckBox则会使用逗号,以及空格将选择值拼接为字符串。这样便可以在定义模型（比如User）的时候，成员变量可以直接使用Date类型，boolean类型等，而CheckBox的值也可以不使用字符串数组String[]保存，使用字符串即可。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2]]></title>
    <url>%2F2019%2F05%2F29%2Fstruts2%2F</url>
    <content type="text"><![CDATA[一、介绍Struts2是Apache发行MVC开源框架，也就是表现层框架。MVC包括： M：Model，用于封装数据，javabean V：View，用于展示数据，jsp C：Controller，控制程序的流程，servlet、filter 二、使用 创建一个javaweb项目，导入Struts2的相关jar包 配置web.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!-- 配置一个拦截器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 该strut过滤器拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 在src目录下创建 struts.xml,配置如下 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt;&lt;!-- package表示包 name：包名 extends：继承，默认是struts-default action:动作 name：相当于servlet的映射路径 class：处理请求的类,相当于一个servlet method：处理请求的方法 result：结果，写返回的jsp页面--&gt;&lt;package name="p1" extends="struts-default"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction" method="sayHello"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt;&lt;/struts&gt; 编写一个类，用于处理请求（相当于servlet），类里编写一个方法，返回一个String 12345678package cn.zhuobo.web.action;public class HelloAction &#123; public String sayHello() &#123; System.out.println("Hello action 调用"); return "success"; &#125;&#125; 新建一个jsp页面 123&lt;body&gt;由helloaction返回的jsp页面&lt;/body&gt; 访问hello：http://localhost/hello 三、处理的过程 浏览器请求资源hello，服务器收到请求 在 struts.xml匹配 name=&#39;hello&#39;的标签，由此将请求交给对应的class、class里的method处理 根据method指定的方法返回的字符串 “success” 找到对应name为success的result标签，将success.jsp转为静态页面响应回客户端 struts流程图： struts架构图，解释了struts处理请求的过程 四、struts配置文件加载的顺序 加载顺序 顺 序 配置文件名 所在位置 说明 1 default.properties struts2-core-2.3.15.3.jar\org\apache\struts2 不能修改 2 struts-default.xml struts2-core-2.3.15.3.jar 不能修改 3 strtuts-plugin.xml 在struts2提供的插件jar包中 不能修改 4 struts.xml 我们的应用中 可以修改的：推荐 5 struts.properties 我们的应用中 可以修改的 6 web.xml 我们的应用中 可以修改的，可以给过滤器配置参数 后加载的配置文件可以覆盖前面的配置文件； default.properties的一些默认的配置信息 配置 作用 struts.i18n.encoding=UTF-8 使用编码集为UTF-8 struts.action.extension=action,, 默认访问的扩展后缀为.action或者空（没有后缀） struts.devMode = false 开发者模式默认关闭，设置为true在出错的时候可以显示更加详细 修改访问后缀的三种方式，要注意的是以下一旦配置了就会覆盖default.properties的后缀action或者空后缀 方法1：在struts.xml中配置 &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do&quot;&gt;&lt;/constant&gt; 方法2：在src下创建配置文件，名为struts.properties，文件内容为 struts.action.extension=do 方法3：在web.xml中配置如下，后缀为ddd 123456789&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.action.extension&lt;/param-name&gt; &lt;param-value&gt;ddd&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 配置为开发模式：在struts.xml中配置一个常量，显示更为详细的错误新仙尼 &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; 五、struts.xml配置文件的元素1. package元素，表示包，相关属性如下 属性 作用 name 包名，必须的属性，并且是在struts配置中包名要唯一 extends 继承，表示继承的包，一般都要继承 struts-default，该包邮转发、重定向等功能，继承这个包可以使用struts的核心功能 abstract 抽象，值为true表示这个包是抽象的，可以用来被其他的包继承，只要这个包没有action元素都可以被声明为抽象的 namespace 命名空间，访问路径 = 命名空间 + 动作名 2. namespace的查找规则namespace的默认值是一个空字符串，如果配置的值为 /user（注意要加/斜杠），那么访问路径就是 user/helloAcion.do 12345&lt;package name="p1" extends="struts-default" namespace="/user"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction" method="sayHello"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 如果访问的是：http://localhost:8080/demo1/a/b/user/hello.action 首先查找是否还有package的namespace为 /a/b/user 如果有，就访问这个包里的对应的hello.action 如果没有，就查找是否有namespace为 /a/b的包，依次类推 因此如果有一个package的namespace值为 /user，(如上面的配置)，那么http://localhost:8080/demo1/a/b/user/hello.action是不可以访问到hello.action的，但是http://localhost:8080/demo1/user/a/b/hello.action是可以访问到hello.action的，因为最后会查找到是否有 /user 这个命名空间，然后访问该包下的action。 3. action元素，用于配置动作，处理请求路径，属性如下： 属性 作用 name 动作名，相当于servlet的映射路径 class 动作类的全类名，是处理请求的类，相当于一个servlet method 动作类里处理请求的方法 动作类有3中写法： 第一种写法：直接写一个action类，然后再struts.xml里配置 123456public class HelloAction1 &#123; public String sayHello() &#123; System.out.println("Hello action 调用"); return "success"; &#125;&#125; 12345&lt;package name="p1" extends="struts-default" namespace="/user1"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction1" method="sayHello"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第二种写法：写一个action类，实现Action接口，overridee execute方法，在struts配置action元素时，不用指定method，因为默认就是执行动作类的execute方法 123456public class HelloAction2 implements Action &#123; @Override public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; struts.xml 12345&lt;package name="p2" extends="struts-default" namespace="/user2"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction2"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第三种写法：写一个action类，继承ActionSupport类（ActionSupport类是实现了Action的类） 1234567import com.opensymphony.xwork2.ActionSupport;public class HelloAction3 extends ActionSupport &#123; public String login()&#123; return SUCCESS; &#125;&#125; struts.xml 12345&lt;package name="p3" extends="struts-default" namespace="/user3"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction3" method="login"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 默认的动作类：就是当配置了一个action元素，但是没有指定class，也没有指定method，那么就会默认找ActionSupport类去处理这个请求。由于由于struts.xml是在struts-default.xml后加载的，因此默认的动作类是可以修改，可以修改成自己写的类。 在package元素下配置一个default-class-ref，class指定自己的动作类。 1&lt;default-class-ref class="cn.zhuobo.web.action.HelloAction1"&gt;&lt;/default-class-ref&gt; 动作访问的通配符： 当实现用户的增删改查的时候，可以在一个UserAction里写add、delete、update、find的方法分别实现，这个时候的动作类可以是类似以下的类的定义： 123456789101112131415161718public class UserAction extends ActionSupport &#123; // 添加用户 public String add()&#123; return SUCCESS; &#125; // 删除用户 public String delete()&#123; return SUCCESS; &#125; // 更新用户 public String update()&#123; return SUCCESS; &#125; // 查询用户 public String find()&#123; return SUCCESS; &#125;&#125; 但是，当配置struts.xml的时候就会发现配置比较麻烦，对于这几个功能的配置应该如下。可以看出来要为每一个功能配置一个action元素，而且很多重复性的工作，比如每一个action都是同一个class，name、method、xxx.jsp其实都是同名的。 123456789101112131415161718&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;!-- 添加用户的动作 --&gt; &lt;action name="add" class="cn.zhuobo.web.action.UserAction" method="add"&gt; &lt;result name="success"&gt;/add.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 删除用户的动作 --&gt; &lt;action name="delete" class="cn.zhuobo.web.action.UserAction" method="delete"&gt; &lt;result name="success"&gt;/delete.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 更新用户的动作 --&gt; &lt;action name="update" class="cn.zhuobo.web.action.UserAction" method="update"&gt; &lt;result name="success"&gt;/update.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 查询用户的动作 --&gt; &lt;action name="find" class="cn.zhuobo.web.action.UserAction" method="find"&gt; &lt;result name="success"&gt;/find.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 可以使用通配符是简化这种配置，使用通配符后配置应该如下： {1}：代表这是第一个通配符* 12345&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;action name="*" class="cn.zhuobo.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 如果是定义了一个动作类如下，可以使用两个通配符*： 1234567891011public class StudentAction extends ActionSupport &#123; // add student public String addStudent() &#123; return SUCCESS; &#125; // delete student public String deleteStudent() &#123; return SUCCESS; &#125;&#125; struts.xml 12345&lt;package name="studentPackage" extends="struts-default" namespace="/student"&gt; &lt;action name="*_*" class="cn.zhuobo.web.action.StudentAction" method="&#123;1&#125;&#123;2&#125;"&gt; &lt;result name="success"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 当访问 http://localhost/student/add_Student，便可以执行响应的动作类的方法。 使用绝对的匹配和通配符的方法匹配，当两种方法都使用的时候，绝对匹配的优先，通配符的方法，根据在配置文件的位置顺序优先。 4. result元素作用：为动作指定结果视图 属性：name、type name：逻辑视图的名称，对应着动作的方法的返回值，默认是 success type：结果类型，指的是用什么方法跳转到指定的页面，默认是 dispatcher type的取值： type取值 作用 dispatcher 默认值，使用请求转发，转发到一个页面 redirect 使用重定向，转向一个页面 chain 转发到另一个action，可以是同一个包或者是不同一个包 redirectAction 重定向到另一个action，可以是同一个包或者不同一个包 dispatcher和redirect是用于对页面的请求转发和重定向的，而chain和redirectAction是用于对action的请求转发和重定向的。下面是配置的方法： dispatcher、redirect 123456789&lt;!-- 默认是dispatcher --&gt;&lt;action name="*_*" class="cn.zhuobo.web.action.StudentAction" method="&#123;1&#125;&#123;2&#125;"&gt; &lt;result name="success"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt;&lt;!-- redirect--&gt;&lt;action name="*_*" class="cn.zhuobo.web.action.StudentAction" method="&#123;1&#125;&#123;2&#125;"&gt; &lt;result name="success" type="redirect"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt; chain、redirectAction 12345678910111213141516&lt;!-- 转发或者重定向到同一个包的action --&gt;&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;action name="*" class="cn.zhuobo.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success" type="chain"&gt;action2&lt;/result&gt; &lt;/action&gt;&lt;/package&gt;&lt;!-- 转发或者重定向到另一个包的action，需要添加参数param元素 --&gt;&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;action name="*" class="cn.zhuobo.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success" type="chain"&gt; &lt;param name="namespace"&gt;/student&lt;/param&gt; &lt;param name="actionName"&gt;&#123;1&#125;_Student&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 5. 自定义一个结果视图（result的type类型）结果类型就是一个类，这些结果类型的类都是实现了 com.opensymphony.xwork2.Result接口，或者是继承了这个接口的实现类 org.apache.struts2.dispatcher.StrutsResultSupport。这些类都有一个 doExecute方法，用于执行结果视图。struts的内部本质上就是一个servlet，因此可以自定义一个结果视图，只要提供实现 Result接口，复写doExecute方法即可。下面举一个用于输出验证码的结果类型的例子： 定义一个类 CAPTCHAResult类，继承 StrutsResultSupport类，在类里面覆盖重写 doExecute方法，该方法的逻辑就是生成验证码 –&gt; 写回验证码到客户端 12345678910111213141516public class CAPTCHAResult extends StrutsResultSupport &#123; private int width; private int height; // 这里提供width和height的getter和setter方法，用于给struts注入参数 @Override protected void doExecute(String s, ActionInvocation actionInvocation) throws Exception &#123; // 1. 创建一个验证码，高度、验证码个数、线条数 ValidateCode code = new ValidateCode(width, height, 4, 8); // 2. 获取response对象 HttpServletResponse response = ServletActionContext.getResponse(); // 3. 写回给客户端 code.write(response.getOutputStream()); &#125;&#125; ValidateCode是一个生成验证码的小框架。 配置struts.xml文件 123456789101112131415&lt;!-- 在这个包里声明一个验证码的结果类型--&gt;&lt;package name="p" extends="struts-default" namespace="/n"&gt; &lt;!-- 在这里声明了一个局部的结果视图，就仅仅可在这个包里使用--&gt; &lt;result-types&gt; &lt;result-type name="captcha" class="cn.zhuob.web.result.CAPTCHAResult"&gt;&lt;/result-type&gt; &lt;/result-types&gt; &lt;action name="checkcode"&gt; &lt;result name="success" type="captcha"&gt; &lt;!--使用param元素为结果类注入参数--&gt; &lt;param name="width"&gt;200&lt;/param&gt; &lt;param name="height"&gt;40&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt; result元素里的param子元素：如果在动作类中有与param的name相同的属性，struts会自动请求参数并将参数值通过setter方法设置到类的同名属性中。 展示：访问 http://localhost/n/checkcode 6. 局部结果视图和全局的结果视图按照前面定义的结果视图，是一个局部视图，只能在包内访问，在另一个包是不能访问的。要使不同的包都可以访问同一个视图，那么就要定义为全局视图。参考抽取一个BaseServlet，在BaseServlet的service方法里完成方法的分发，让其他的servlet继承BaseServlet的方法。这里也可以定义一个抽象的包，在这个抽象的包里定义一个结果视图，其他的包继承这个抽象包便都可以访问这个结果视图。 抽象包：没有action元素，用来继承 123456789101112&lt;package name="myDefault" extends="struts-default" abstract="true"&gt; &lt;result-types&gt; &lt;result-type name="captcha" class="cn.zhuob.web.result.CAPTCHAResult"&gt;&lt;/result-type&gt; &lt;/result-types&gt; &lt;global-results&gt; &lt;result name="success" type="captcha"&gt; &lt;param name="width"&gt;500&lt;/param&gt; &lt;param name="height"&gt;100&lt;/param&gt; &lt;/result&gt; &lt;/global-results&gt;&lt;/package&gt; 要访问全局视图的包：继承包myDefault 123&lt;package name="p" extends="myDefault" namespace="/n"&gt; &lt;action name="checkcode"&gt;&lt;/action&gt;&lt;/package&gt; 六、获取Servlet的request、response等对象1. 通过ServletActionContext类获取12345678910111213141516171819public class TestAction extends ActionSupport &#123; public String test() &#123; // 获取request、response、session、application // 1. 通过ServletActionContext获取 HttpServletRequest request = ServletActionContext.getRequest(); // StrutsRequestWrapper --&gt; 属于struts，是HttpServletRequest的实现类 HttpServletResponse response = ServletActionContext.getResponse(); // ResponseFacade --&gt; 属于tomcat，是HttpServletResponse的实现类 HttpSession session = request.getSession(); // StandardSessionFacade --&gt; 属于tomcat，是HttpSession的实现类 ServletContext application = ServletActionContext.getServletContext(); // ApplicationContextFacade --&gt; 属于tomcat return NONE; &#125;&#125; 2. 通过注入的方法，要实现XXXAware接口123456789101112131415161718192021222324252627282930313233public class TestAction extends ActionSupport implements ServletRequestAware, ServletResponseAware, ServletContextAware &#123; private HttpServletResponse response; private HttpServletRequest request; private ServletContext application; public String test() &#123; System.out.println(request); System.out.println(response); System.out.println(application); return NONE; &#125; @Override public void setServletRequest(HttpServletRequest httpServletRequest) &#123; this.request = httpServletRequest; System.out.println("注入" + this.request); &#125; @Override public void setServletResponse(HttpServletResponse httpServletResponse) &#123; this.response = httpServletResponse; System.out.println("注入" + this.response); &#125; @Override public void setServletContext(ServletContext servletContext) &#123; this.application = servletContext; System.out.println("注入" + this.application); &#125;&#125; 这种通过注入的方法是由struts的拦截器实现的。根据前面的struts结构图，要访问Action首先要经历一系列的拦截器（Interceptor），拦截器首先会对被访问的action对象作出一些处理。在这种获取方式里，&lt; interceptor name=&quot;servletConfig&quot;class=&quot;org.apache.struts2.interceptor.ServletConfigInterceptor&quot;/&gt;这个拦截器将调用上面的三个方法注入。查看 ServletConfigInterceptor的源码： 访问action前要先访问拦截器，ServletConfigInterceptor拦截器的主要作用是获取要被访问的action，然后判断是否实现了 ServletRequestAware、ServletResponseAware、ServletContextAware等接口，如果实现了获取相应的HttpServletRequest、HttpServletResponse、ServletContext，然后调用Action的setter方法注入。 七、多个struts.xml的配置当开发的功能越来越多，应用的规模越来越复杂，随着action的增加，struts.xml不可避免的变得越来越臃肿，而且还不利于模块分工的开发。为了增加struts.xml的可读性、利于模块开发、减少冲突，可以将struts.xml分解为多个配置文件，典型的就是根据功能模块去划分。比如，当应用可以分为user、order、pay三个功能，都在同一个struts.xml中配置会是这种形式： struts.xml 1234567891011121314&lt;!-- user模块--&gt;&lt;package name="p1" extends="struts-default" namespace="/user"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt;&lt;!-- order模块--&gt;&lt;package name="p2" extends="struts-default" namespace="/order"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt;&lt;!-- pay模块--&gt;&lt;package name="p3" extends="struts-default" namespace="/pay"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; 当采取划分多个为多个配置文件的方式，只需要每个模块分别写自己的配置文件，在struts.xml中包含这些配置文件即可。 struts-user.xml 1234&lt;!-- user模块--&gt;&lt;package name="p1" extends="struts-default" namespace="/user"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; struts-order.xml 1234&lt;!-- order模块--&gt;&lt;package name="p2" extends="struts-default" namespace="/order"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; struts-pay.xml 1234&lt;!-- pay模块--&gt;&lt;package name="p3" extends="struts-default" namespace="/pay"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; 然后再struts.xml中包含以上3个xml 123&lt;include file="struts-user.xml"&gt;&lt;/include&gt;&lt;include file="struts-order.xml"&gt;&lt;/include&gt;&lt;include file="struts-pay.xml"&gt;&lt;/include&gt; 八、Action接收请求参数1. 通过servlet获取，先获取request对象1234567891011public class LoginAction extends ActionSupport &#123; public String login() &#123; HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter("username"); String password = request.getParameter("password"); System.out.println(username); System.out.println(password); return NONE; &#125;&#125; 2. 通过Action属性的setter方法注入在访问action之前，拦截器先获取action，判断Action类是否有password和username属性，如果有就调用对应的setter方法为属性注入值。 123456789101112131415161718192021public class LoginAction extends ActionSupport &#123; private String password; private String username; public void setPassword(String password) &#123; System.out.println("set password"); this.password = password; &#125; public void setUsername(String username) &#123; System.out.println("set username"); this.username = username; &#125; public String login() &#123; System.out.println(username); System.out.println(password); return NONE; &#125;&#125; 3. 通过Action属性的模型注入其实也就是不分别注入username、password，Action类提供的是User成员变量，而User有username和password这两个成员变量。还是一样的过程，拦截器首先判断Action类是否有user这个属性，如果有就调用setUser方法注入参数。 提交的表单：注意name的值是user.username、user.password 12345&lt;form action="$&#123;pageContext.request.contextPath&#125;/login.do"&gt; username:&lt;input type="text" name="user.username"&gt; password:&lt;input type="password" name="user.password"&gt; &lt;input type="submit" value="登录"&gt;&lt;/form&gt; LoginAction：提供setUser、getUser方法 123456789101112131415161718public class LoginAction extends ActionSupport &#123; private User user; public void setUser(User user) &#123; System.out.println("set user"); this.user = user; &#125; public User getUser() &#123; System.out.println("get user"); return this.user; &#125; public String login() &#123; System.out.println(user); return NONE; &#125;&#125; 根据输出结果：getUser方法执行了2次，setter方法执行了1次，过程是：tomcat服务器创建Action实例，得到Action的具体信息，成员变量User、成员方法setter、getter，然后tomcat执行拦截器的内容，也就是判断是否有user这个属性，那么就调用setUser注入参数。过程如下：1. 首先调用getUser发现user为null；2. new 一个Use；3. 调用setUser设置user为new出来的user；3. 设置password；4. getUser，获取user去设置username 4. Action的模型驱动封装参数这个工作也是一个拦截器做了，这个拦截器叫模型驱动拦截器 com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor，它不会创建模型，因此Action提供的模型属性要自己new出来赋值。 Action实现一个 ModelDriven&lt;User&gt;接口，覆盖重写 getModel方法； Action提供一个模型属性，并且要赋值； 这种方法，表单的name就不用写user. Action: 12345678910111213public class LoginAction extends ActionSupport implements ModelDriven&lt;User&gt; &#123; private User user = new User();// user 要赋值！！ public String login() &#123; System.out.println(user); return NONE; &#125; @Override public User getModel() &#123; return user; &#125;&#125; 表单： 12345&lt;form action="$&#123;pageContext.request.contextPath&#125;/login.do"&gt; username:&lt;input type="text" name="username"&gt; password:&lt;input type="password" name="password"&gt; &lt;input type="submit" value="登录"&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lunix基础]]></title>
    <url>%2F2019%2F05%2F28%2FLunix%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、linux的应用领域 基于linux的企业服务器：很多公司使用Linux作为服务端系统 嵌入式应用：安卓、智能家居、银行系统等 Linux在电影娱乐业的应用 二、常用命令命令基本格式：命令 [-选项] [参数]，例如：ls -la /usr 当有多个选项，可以写在一起 1. 目录、文件处理命令 ls：-l（long，显示详细信息）；-h（human，大小按kb、MB显示）；-a（显示隐藏文件）；-d（显示目录本身而非目录下文件的信息） mkdir：-p（递归创建，可以创建中间尚未存在的目录） pwd：打印当前目录的路径 rmdir：删除空目录；-r（） cp：cp 源文件 目标目录；-p（保存文件的属性，如修改时间等）；-r（复制目录）； mv：移动，移动目录不用加-r选项 rm：-r（删除目录）；-f（强制删除）； touch：创建文件 cat：查看文件；-n（查看的时候可以显示行号） more：查看文件，回车（翻页）；空格（换行）；q（退出） less：查看文件，可以向上翻页 head：查看文件 hean -n 20 filename（查看前20行） tail：和head类似，查看文件末尾 2. 更改文件权限 chmod：读r、写w、执行x三种权限用数字4、2、1表示，如 chmod 777 filename，表示所有用户拥有所有权限 权限对于文件和目录的含义不同：对于文件来说写w是修改文件，对于目录来说写w是在目录里创建删除目录（文件） chown：改变文件的所有者。chown 用户 文件或者目录（将文件的所有这改为新的所有者） chgrp：改变文件的所属组。chown 用户组 文件或者目录； umask：查看默认的创建文件、目录的权限 3. 文件搜索命令 find：find [搜索范围] [匹配条件] -name：匹配条件为文件名，*匹配任意字符串，？匹配任意单个字符，find /etc -name init -iname：不区分大小写的文件名 -size：+n（文件大小大于），-n（文件大小小于），=n（文件大小等于） -amin：匹配条件为访问时间，在/etc目录下查找5分钟内被访问过的文件 find /etc -amin -5 -mmin：匹配条件为修改时间，在/etc目录下查找30分钟内被修改过的文件 `find /etc -mmin -30 -type：匹配条件为文件类型，f表示文件，d表示目录 -a：当有多个查询条件时，使用-a连接，表示and -o：当有多个查询条件时，使用-o连接，表示or locate：类似于everything -i：不区分大小写 updatdb：更新文件资料库 grep：在文件内容中查找 sudo grep mysql /root/install.log -v：排除包含指定字符的行，如排除以#开始的行（也就是注释行）grep -v ^# mysql /root/install.log man：命令的帮助信息 man ls：查看ls的帮助信息 4.关机重启命令 shutdown：-r(重启)、-h(重启)、-c(取消前一个关机重启命令) #### 5. 打包压缩命令 打包压缩为.tar.gz tar -zcvf 打包压缩后的文件名 要打包压缩的文件 tar -zcvf xxx1.tar.gz a.txt b.python c.cpp dir1 dir2 tar -zcvf /usr/* 解压缩，-C 加解压后文件的位置 tar -xvf 压缩包 tar -xvf xxx.tar.gz(解压缩后放在当前目录) tar -xvf xxx.tar.gz -C ~/Desktop(解压缩后放在Desktop) zip压缩解压缩 压缩：zip -r xxx.zip ./*，将当前录下所有文件包括目录压缩为xxx.zip 解压缩：unzip -o -d ~/Desktop/dir xxx.zip，将xxx.zip解压到桌面下的dir目录，并且重复了（-o）也不提示就覆盖 5. vim常用操作、技巧 常用操作 插入命令： 命令 插入位置 i 在光标所在字符前插入 I 在光标所在行首插入 o 在光标下一行插入新行 O 在光标下一行插入新行 a 在光标所在字符后插入 A 在光标所在行尾插入 定位命令： 命令 作用 ：set nu 设置行号 ：set nonu 取消行号 x 删除光标所在处字符 nx 删除光标所在处后n个字符 dd 删除光标所在行 ndd 删除n行 D 删除光标所在处到行尾内容 复制剪切命令： 命令 作用 yy 复制当前行 nyy 复制当前行以下n行 dd 剪切当前行 ndd 剪切当前行以下n行 p、P 粘贴在当前行上、或者行下 取消和替换： 命令 作用 u 取消上一步操作 R 从光标所在处开始替换，知道按esc r 替换光标所在字符 查找： 命令 作用 /string 搜索指定字符串，如果要忽略大小写先输入命令 :set ic 退出和保存： 命令 作用 :w 保存修改 :w new_filename 另存为新文件 :wq 保存修改并退出 :q! 不保存修改退出 ZZ 快捷键，保存修改并退出]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F05%2F28%2FRedis%2F</url>
    <content type="text"><![CDATA[一、概念Redis是一款高性能的NOSQL系列（NoSQL = Not Only SQL ）的数据库 1.1.什么是NOSQL​ NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。​ 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 ​ 1.1.1. NOSQL和关系型数据库比较​ 优点：​ 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。​ 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。​ 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。​ 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 ​ 缺点：​ 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。​ 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。​ 3）不提供关系型数据库对事务的处理。 ​ 1.1.2. 非关系型数据库的优势： ​ 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。​ 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 ​ 1.1.3. 关系型数据库的优势：​ 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。​ 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 ​ 1.1.4. 总结​ 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，​ 让NoSQL数据库对关系型数据库的不足进行弥补。​ 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品​ • 键值(Key-Value)存储数据库​ 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB​ 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。​ 数据模型： 一系列键值对​ 优势： 快速查询​ 劣势： 存储的数据缺少结构化​ • 列存储数据库​ 相关产品：Cassandra, HBase, Riak​ 典型应用：分布式的文件系统​ 数据模型：以列簇式存储，将同一列数据存在一起​ 优势：查找速度快，可扩展性强，更容易进行分布式扩展​ 劣势：功能相对局限​ • 文档型数据库​ 相关产品：CouchDB、MongoDB​ 典型应用：Web应用（与Key-Value类似，Value是结构化的）​ 数据模型： 一系列键值对​ 优势：数据结构要求不严格​ 劣势： 查询性能不高，而且缺乏统一的查询语法​ • 图形(Graph)数据库​ 相关数据库：Neo4J、InfoGrid、Infinite Graph​ 典型应用：社交网络​ 数据模型：图结构​ 优势：利用图结构相关算法。​ 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis​ Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：​ 1) 字符串类型 string​ 2) 哈希类型 hash​ 3) 列表类型 list​ 4) 集合类型 set​ 5) 有序集合类型 sortedset​ 1.3.1 redis的应用场景​ • 缓存（数据查询、短连接、新闻内容、商品内容等等）​ • 聊天室的在线好友列表​ • 任务队列。（秒杀、抢购、12306等等）​ • 应用排行榜​ • 网站访问统计​ • 数据过期处理（可以精确到毫秒​ • 分布式集群架构中的session分离 二、命令操作1. Redis的数据结构Redis存储的是键值对，key都是字符串，value可以有5种不同的类型数据： 字符串 string 哈希类型 hash：map格式，可以存储键值对 列表类型 list：linkedlist格式，元素可以重复 集合类型 set 元素不可以重复 有序集合类型 sortedset 元素可以重复而且有序 2. Redis命令操作 字符串string 存储：set key value 获取：get key 删除：del key 哈希类型 hash 存储：hset key field value 获取： hget key field：获取指定的field对应的值 hgetall key：获取所有的field和value 删除：hdel key field 1234hset myhash username Tomhset myhash age 18hget myhash age -- 18 列表类型 list：可以添加一个元素到列表的头部（左）或者尾部（右） 存储： lpush key value：将元素加入列表左边 rpush key value：将元素加入列表右边 获取： lrange key start end：范围获取 删除： lpop：删除最左边元素，并返回该元素 rpop：删除最右边元素，并返回该元素 12345lpush mylist alpush mylist blpush mylist c -- a-&gt;b-&gt;clrange mylist 0 -1 -- 获取mylist所有的元素 集合类型 set 存储：sadd key value 获取：smembers key：获取集合中所有的元素 删除：srem key value：删除集合中某个元素 有序集合类型 sortedset 存储：zadd key score value 获取：zrange key start end（withscores） 删除：zrem key value 1234567891011 127.0.0.1:6379&gt;zadd sorted 10 aaa(integer) 1127.0.0.1:6379&gt; zadd sorted 30 bbb(integer) 1127.0.0.1:6379&gt; zadd sorted 20 ccc(integer) 1127.0.0.1:6379&gt; zrange sorted 0 -1// 按照分数（score）排序1) &quot;aaa&quot;2) &quot;ccc&quot;3) &quot;bbb&quot; 常用的通用命令： keys *：查询所有的键 type key：获取键对应的value的类型 del key：删除指定的key以及该key对应的value 三、Redis持久化Redis是一个基于内存的数据库，因此当Redis服务器重启会导致数据丢失，可以将Redis数据库的数据存储到硬盘。 1. Redis持久化机制 RDB: 默认方式，不需要进行配置，默认使用的机制，在一定的时间间隔内，检测key的变化情况，然后持久化数据 编辑配置文件：redis.windows.conf 1234567# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changedsave 900 1save 300 10save 60 10000 重新启动Redis服务器，并且指定配置文件:$ redis-server.exe redis.windows.conf AOF: 记录日志的方式，可以记录每一条操作的命令，操作命令后就持久化数据（这样的效果和mysql类似了） 编辑配置文件：redis.windows.conf 12345678# 开启aof模式appendonly no --&gt; appendonly yes# aof模式下的三种持久化方式# appendfsync always # 总是，每一条操作都持久化appendfsync everysec # 每间隔1s进行一次持久化# appendfsync no # 不进行持久化 四、Java客户端Jedis Jedis是一款java操作Redis数据库的工具，类似于JDBC 使用步骤： 下载、导入jar包 使用 使用Demo 12345678910111213141516@Testpublic void test2() &#123; // 获取连接, 如果使用的是空参数的构造，那么默认就是localhost和6379 Jedis jedis = new Jedis("localhost", 6379); // 操作 jedis.set("username", "David"); String username = jedis.get("username"); System.out.println(username);// David // 可以使用方法setex来存储指定的过期时间的key value jedis.setex("activeCode", 20, "didi");// 20秒后键activeCode、值didi就被自动删除 // 关闭连接 jedis.close();&#125; Jedis连接池 12345678910111213141516171819@Testpublic void test5() &#123; // 创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50);// 最大的允许连接数量 config.setMaxIdle(10);// 最大的空闲连接数 // 创建一个JedisPool连接池对象 JedisPool jedisPool = new JedisPool(config, "localhost", 6379); // 获取连接 Jedis jedis = jedisPool.getResource(); // 使用 jedis.set("username", "Tom"); // 归还连接给连接池 jedis.close();&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
</search>
