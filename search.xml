<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[struts2拦截器]]></title>
    <url>%2F2019%2F06%2F04%2Fstruts2%E6%8B%A6%E6%88%AA%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一、struts2拦截器介绍struts2的许多功能都是建立在拦截器之上的，比如国际化、转换器、校验等功能。拦截器是动态拦截Action调用的对象，它提供了一种可以使开发者定义在一个Action执行前后执行的代码，也可以在Action执行前阻止其执行。拦截器栈（Interceptor stack），或者说拦截器链（Interceptor China）就是将拦截器按一定的顺序联结成一条链。在访问被拦截的方法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。 struts2的默认拦截器在配置文件 struts-default.xml中配置。拦截器是AOP编程思想的一种应用的形式。 当请求到达Struts 2的ServletDispatcher时，Struts 2会查找配置文件，并根据其配置实例化相对的拦截器对象，然后串成一个列表（list），最后一个一个地调用列表中的拦截器。拦截器链在执行Action前顺序执行，执行Action后倒序执行。 拦截器Interceptor的类的继承、实现结构: 二、自定义拦截器]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[struts2国际化]]></title>
    <url>%2F2019%2F06%2F03%2Fstruts2%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[一、软件的国际化为了使不同国家和地区的人可以使用到使用该地区的网站、应用，网站必须适配不同国家和地区的语言，而且还要使软件的开发与特定的语言脱钩。也就是说不能专门为了适配中文写一个软件、适配英文再写一个软件、适配繁体字也写一个软件，做到当软件在不通的国家和地区被使用就可以不必更改代码就可以适应该地区的语言。 苹果官网为不同的地区适配了不同的语言。 二、读取国际化数据1. 创建国际化的资源数据在src目录下创建resources资源目录，在resources目录里创建创建国际化资源数据，命名的方法为xxx_语言_地区.properties。比如可以创建中国大陆的国际化数据，资源文件名为message_zh_CN.properties，创建美国的国际化资源数据message_en_US.properties。资源文件的内容如下，就可以实现访问同一个注册页面，当用户在美国注册页面显示中文，在中国大陆注册显示简体中文。 2. java中读取国际化的数据12345678910111213141516171819202122232425262728@Testpublic void test1() &#123; //读取国际化的资源数据 // 使用ResourceBundle读取国际化的数据，这是读取默认的语言 //ResourceBundle rb = ResourceBundle.getBundle("resources.message"); //读取指定的地区的语言的数据 //ResourceBundle rb = ResourceBundle.getBundle("resources.message", Locale.US); /* USERNAEM PASSWORD REPASSWORD SUBMIT */ ResourceBundle rb = ResourceBundle.getBundle("resources.message", Locale.CHINA); /* 用户名 密码 确认密码 提交 */ System.out.println(rb.getString("login.username")); System.out.println(rb.getString("login.password")); System.out.println(rb.getString("login.repassword")); System.out.println(rb.getString("login.submit"));&#125; 3. 在jsp中读取国际化的数据和java中类似的，只是中jsp标签之中写java代码，当然jsp本质上就是java。 4. 在jstl中读取国际化的数据三、struts国际化的实现步骤1. 配置资源包 配置全局的资源包 在src目录下创建resources资源目录，在resources目录里创建创建国际化资源数据，命名的方法为xxx_语言_地区.properties。这种方法创建的资源包就是全局资源包。要在struts.xml中配置。指定国际化数据的资源包，全局的资源包的意思就是指任何一个jsp页面访问的数据都是这个资源包下的数据； 1&lt;constant name="struts.custom.i18n.resources" value="resources.message"&gt;&lt;/constant&gt; 配置包范围的资源包 在web包下配置包范围的资源包，资源包的命名规范是 package_语言代码_地区代码.properties，资源包内容还是一样，在web包下配置这种资源包，表示该资源包可以被web下的Action访问，这种资源包的访问优先级高于全局消息资源包，也就是说如果配置了包范围的资源包，有限访问包范围的资源包，没有便访问全局消息资源包。 配置局部消息资源包 在action包下配置资源文件，命名规则为 Action类名_语言代码_地区代码.properties，表示该资源包只能被指定的Action类访问，文件内容还是一致的，这个资源包的优先级是三者中最高。如命名为 UserAction_zh_CN.properties。 再次总结一下，这种中资源包的范围由大到小，优先级由低到高，也就是优先级采取就近原则。 2. 读取资源包数据 使用struts的text标签获取国际化资源包的内容 123456&lt;form&gt; &lt;s:text name="login.username" /&gt;&lt;input type="text" name="username"&gt;&lt;br&gt; &lt;s:text name="login.password" /&gt;&lt;input type="text" name="password"&gt;&lt;br&gt; &lt;s:text name="login.repassword" /&gt;&lt;input type="text" name="repassword"&gt;&lt;br&gt; &lt;input type="submit" value="&lt;s:text name='login.submit' /&gt;"&gt;&lt;/form&gt; 访问该注册页面，会根据浏览器的语言版本读取到不同的数据。 中文版的Chrome： 英文版的Firefox： 在Action中读取资源包的内容 ActionSupport类提供了一个 getText()方法用来获取资源数据，也就是Action必须继承ActionSupport类，这种获取方法在开发中几乎不用。 123456789101112131415public class HelloAction extends ActionSupport &#123; public String sayHello() &#123; System.out.println("hello"); System.out.println(getText("login.username")); System.out.println(getText("login.password")); System.out.println(getText("login.submit")); return NONE; /* hello USERNAME-P PASSWORD-P SUBMIT-P */ &#125;&#125; 指定要读取的资源包，可以使用 s:i18n标签指定要读取的国际化资源包文件。如下，指定读取包范围的资源包。 12345678&lt;form&gt; &lt;s:i18n name="cn.zhuobo.web.package"&gt; &lt;s:text name="login.username" /&gt;&lt;input type="text" name="username"&gt;&lt;br&gt; &lt;s:text name="login.password" /&gt;&lt;input type="text" name="password"&gt;&lt;br&gt; &lt;s:text name="login.repassword" /&gt;&lt;input type="text" name="repassword"&gt;&lt;br&gt; &lt;input type="submit" value="&lt;s:text name='login.submit' /&gt;"&gt; &lt;/s:i18n&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[struts2表单校验]]></title>
    <url>%2F2019%2F06%2F02%2Fstruts2%E8%A1%A8%E5%8D%95%E6%A0%A1%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[一、struts的表单标签 在jsp页面引入struts标签 1&lt;%@ taglib uri="/struts-tags" prefix="s"%&gt; 使用form标签 1234567891011121314151617&lt;html&gt;&lt;head&gt; &lt;title&gt;register&lt;/title&gt; &lt;s:head&gt;&lt;/s:head&gt;&lt;/head&gt;&lt;body&gt; &lt;s:form action="user/register.do"&gt; &lt;s:textfield name="username" label="用户名" requiredLabel="true" requiredPosition="left"&gt;&lt;/s:textfield&gt; &lt;s:password name="password" label="密码" requiredLabel="true" requiredPosition="left"&gt;&lt;/s:password&gt; &lt;s:textfield name="birthday" label="生日"&gt;&lt;/s:textfield&gt; &lt;s:checkboxlist list="#&#123;'篮球':'篮球','足球':'足球','泡妞':'泡妞'&#125;" name="hobby" label="爱好"&gt;&lt;/s:checkboxlist&gt; &lt;s:radio list="#&#123;'true':'已婚', 'false':'未婚'&#125;" name="married" label="是否已婚"&gt;&lt;/s:radio&gt; &lt;s:submit value="注册"&gt;&lt;/s:submit&gt; &lt;/s:form&gt; &lt;br&gt;&lt;/body&gt;&lt;/html&gt; 显示效果如下： struts表单的优点： 自带了一定了样式，比如对齐 方便标记字段是否为必须填写 方便数据的回显 方便显示校验的信息 二、struts的表单在Action校验 在提交表单的Action（继承了ActionSupport类）的覆盖重写方法validate,这是一个全局的方法,也就是在该Action里的任何方法要执行，就要首先执行这个 validate方法。 1234567891011@Overridepublic void validate() &#123; if (StringUtils.isEmpty(user.getUsername())) &#123; addFieldError("username", "用户名不能为空"); &#125; // 相当于if(user.getPassword() == null || "".equals(user.getPassword())) // 这个工具类封装了这一行代码...... if (StringUtils.isEmpty(user.getPassword())) &#123; addFieldError("password", "密码不能为空"); &#125;&#125; 由于validate方法是一个全局的方法，因此Action里所有的方法执行之前都会先执行该方法，但是如果是这样又有着明显的不合理，总能不能什么方法都要执行校验用户名、密码的逻辑。因此可以在不需要执行validate方法的方法上加上注解@SkipValidation，表示该方法跳过跳过validate方法的验证。 1234@SkipValidationpublic String list() &#123; return "list";&#125; 如果输入用户名密码为空，就会提示： 此外还可以为每个方法写一个验证的方法，这种就是局部的验证方法，方法命名为 validate方法名(方法名首字符大写)，如有一个list方法，那么就写一个validateList方法专门验证list方法 123456789101112131415161718// 专门验证register方法的validate方法 public void validateRegister() &#123; if (StringUtils.isEmpty(user.getUsername())) &#123; addFieldError("username", "用户名不能为空"); &#125; if (StringUtils.isEmpty(user.getPassword())) &#123; addFieldError("password", "密码不能为空"); &#125; &#125; public String register() &#123; System.out.println(user); //调用service注册 userService.register(user); return NONE; &#125; 三、xml配置校验在action里为某个Action类写一个配置文件，表示该Action的所有方法都要进行校验，如Action的名为UserAction，则xml的命名为UserAction-validation.xml，该文件的配置为 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 该dtd在xwork-core-2.3.37.jar--&gt;&lt;!DOCTYPE validators PUBLIC "-//Apache Struts//XWork Validator 1.0.3//EN" "http://struts.apache.org/dtds/xwork-validator-1.0.3.dtd"&gt;&lt;validators&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;username&lt;/param&gt; &lt;message&gt;用户名不能为空-xml&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 这种方式的配置也是全局的配置，默认Action的每个方法都要执行校验，同时，如果有某些方法不希望执行校验在方法上加上注解 @SkipValidation即可跳过校验。 当然，也可以为类的某个方法指定校验，这时候xml文件的命名改为 Action类名-方法名-validation.xml，比如可以命名为 UserAction-register-validation.xml。 1234567891011121314&lt;validators&gt; &lt;!--用户名不能为空--&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;username&lt;/param&gt; &lt;message&gt;用户名不能为空-xml&lt;/message&gt; &lt;/validator&gt; &lt;!-- 密码长度至少为8 --&gt; &lt;validator type="stringlength"&gt; &lt;param name="fieldName"&gt;password&lt;/param&gt; &lt;param name="minLength"&gt;8&lt;/param&gt; &lt;message&gt;密码长度至少为8&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt; 四、采用xml校验一般来说会采用xml的方式校验表单，以减少Action中的代码量。这里是xml校验的几个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;validators&gt; &lt;!--username--&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;username&lt;/param&gt; &lt;message&gt;用户名不能为空&lt;/message&gt; &lt;/validator&gt; &lt;!--age--&gt; &lt;validator type="int"&gt; &lt;param name="fieldName"&gt;age&lt;/param&gt; &lt;param name="max"&gt;100&lt;/param&gt; &lt;param name="min"&gt;10&lt;/param&gt; &lt;message&gt;年龄必须是10~100&lt;/message&gt; &lt;/validator&gt; &lt;!--email使用两种校验，一是不能为空，而是如果填写了就校验格式--&gt; &lt;!--1. 邮箱不能为空--&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;email&lt;/param&gt; &lt;message&gt;邮箱不能为空&lt;/message&gt; &lt;/validator&gt; &lt;!-- 2. 邮箱格式 --&gt; &lt;validator type="email"&gt; &lt;param name="fieldName"&gt;email&lt;/param&gt; &lt;message&gt;邮箱格式不正确&lt;/message&gt; &lt;/validator&gt; &lt;!-- password--&gt; &lt;validator type="requiredstring"&gt; &lt;param name="fieldName"&gt;password&lt;/param&gt; &lt;message&gt;邮箱不能为空&lt;/message&gt; &lt;/validator&gt; &lt;validator type="stringlength"&gt; &lt;param name="fieldName"&gt;password&lt;/param&gt; &lt;param name="minLength"&gt;8&lt;/param&gt; &lt;param name="maxLength"&gt;18&lt;/param&gt; &lt;message&gt;密码长度为8~18&lt;/message&gt; &lt;/validator&gt; &lt;!--确认密码 要和password一致--&gt; &lt;validator type="expression"&gt; &lt;param name="expression"&gt; &lt;![CDATA[password == repassword]]&gt; &lt;/param&gt; &lt;message&gt;密码不一致&lt;/message&gt; &lt;/validator&gt; &lt;validator type="url"&gt; &lt;param name="fieldName"&gt;url&lt;/param&gt; &lt;message&gt;url不合法，以http://开头&lt;/message&gt; &lt;/validator&gt; &lt;validator type="required"&gt; &lt;param name="fieldName"&gt;gender&lt;/param&gt; &lt;message&gt;性别必须选择&lt;/message&gt; &lt;/validator&gt;&lt;/validators&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts问题总结]]></title>
    <url>%2F2019%2F05%2F31%2Fstruts%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在使用struts2框架的过程中遇到的一些问题的总结： 1. 异常Error setting expression ‘xxx’ with value… 在提交表单的时候遇到的这个问题，其实并不影响应用的运行，但是也还是个异常，根据提示可以发现是 Developer Notification，也就是在struts.xml配置了开发模式，才会提醒这个信息，关闭开发模式便不会提醒。但是问题的根本应该是表单对应的参数，比如username和password在Action类里没有提供对应的setter和getter方法，在Action类中提供了便不会有这个异常的提示。 2. struts2的自动类型转换Servlet接收到的表单提交的数据都是字符串String类型的，但是Struts2会自动进行类型转换，比如可以转为Date类型、boolean类型，如果是CheckBox则会使用逗号,以及空格将选择值拼接为字符串。这样便可以在定义模型（比如User）的时候，成员变量可以直接使用Date类型，boolean类型等，而CheckBox的值也可以不使用字符串数组String[]保存，使用字符串即可。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2]]></title>
    <url>%2F2019%2F05%2F29%2Fstruts2%2F</url>
    <content type="text"><![CDATA[一、介绍Struts2是Apache发行MVC开源框架，也就是表现层框架。MVC包括： M：Model，用于封装数据，javabean V：View，用于展示数据，jsp C：Controller，控制程序的流程，servlet、filter 二、使用 创建一个javaweb项目，导入Struts2的相关jar包 配置web.xml 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0"&gt; &lt;!-- 配置一个拦截器 --&gt; &lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;!-- 该strut过滤器拦截所有的请求 --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 在src目录下创建 struts.xml,配置如下 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt;&lt;!-- package表示包 name：包名 extends：继承，默认是struts-default action:动作 name：相当于servlet的映射路径 class：处理请求的类,相当于一个servlet method：处理请求的方法 result：结果，写返回的jsp页面--&gt;&lt;package name="p1" extends="struts-default"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction" method="sayHello"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt;&lt;/struts&gt; 编写一个类，用于处理请求（相当于servlet），类里编写一个方法，返回一个String 12345678package cn.zhuobo.web.action;public class HelloAction &#123; public String sayHello() &#123; System.out.println("Hello action 调用"); return "success"; &#125;&#125; 新建一个jsp页面 123&lt;body&gt;由helloaction返回的jsp页面&lt;/body&gt; 访问hello：http://localhost/hello 三、处理的过程 浏览器请求资源hello，服务器收到请求 在 struts.xml匹配 name=&#39;hello&#39;的标签，由此将请求交给对应的class、class里的method处理 根据method指定的方法返回的字符串 “success” 找到对应name为success的result标签，将success.jsp转为静态页面响应回客户端 struts流程图： struts架构图，解释了struts处理请求的过程 四、struts配置文件加载的顺序 加载顺序 顺 序 配置文件名 所在位置 说明 1 default.properties struts2-core-2.3.15.3.jar\org\apache\struts2 不能修改 2 struts-default.xml struts2-core-2.3.15.3.jar 不能修改 3 strtuts-plugin.xml 在struts2提供的插件jar包中 不能修改 4 struts.xml 我们的应用中 可以修改的：推荐 5 struts.properties 我们的应用中 可以修改的 6 web.xml 我们的应用中 可以修改的，可以给过滤器配置参数 后加载的配置文件可以覆盖前面的配置文件； default.properties的一些默认的配置信息 配置 作用 struts.i18n.encoding=UTF-8 使用编码集为UTF-8 struts.action.extension=action,, 默认访问的扩展后缀为.action或者空（没有后缀） struts.devMode = false 开发者模式默认关闭，设置为true在出错的时候可以显示更加详细 修改访问后缀的三种方式，要注意的是以下一旦配置了就会覆盖default.properties的后缀action或者空后缀 方法1：在struts.xml中配置 &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do&quot;&gt;&lt;/constant&gt; 方法2：在src下创建配置文件，名为struts.properties，文件内容为 struts.action.extension=do 方法3：在web.xml中配置如下，后缀为ddd 123456789&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.action.extension&lt;/param-name&gt; &lt;param-value&gt;ddd&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 配置为开发模式：在struts.xml中配置一个常量，显示更为详细的错误新仙尼 &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; 五、struts.xml配置文件的元素1. package元素，表示包，相关属性如下 属性 作用 name 包名，必须的属性，并且是在struts配置中包名要唯一 extends 继承，表示继承的包，一般都要继承 struts-default，该包邮转发、重定向等功能，继承这个包可以使用struts的核心功能 abstract 抽象，值为true表示这个包是抽象的，可以用来被其他的包继承，只要这个包没有action元素都可以被声明为抽象的 namespace 命名空间，访问路径 = 命名空间 + 动作名 2. namespace的查找规则namespace的默认值是一个空字符串，如果配置的值为 /user（注意要加/斜杠），那么访问路径就是 user/helloAcion.do 12345&lt;package name="p1" extends="struts-default" namespace="/user"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction" method="sayHello"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 如果访问的是：http://localhost:8080/demo1/a/b/user/hello.action 首先查找是否还有package的namespace为 /a/b/user 如果有，就访问这个包里的对应的hello.action 如果没有，就查找是否有namespace为 /a/b的包，依次类推 因此如果有一个package的namespace值为 /user，(如上面的配置)，那么http://localhost:8080/demo1/a/b/user/hello.action是不可以访问到hello.action的，但是http://localhost:8080/demo1/user/a/b/hello.action是可以访问到hello.action的，因为最后会查找到是否有 /user 这个命名空间，然后访问该包下的action。 3. action元素，用于配置动作，处理请求路径，属性如下： 属性 作用 name 动作名，相当于servlet的映射路径 class 动作类的全类名，是处理请求的类，相当于一个servlet method 动作类里处理请求的方法 动作类有3中写法： 第一种写法：直接写一个action类，然后再struts.xml里配置 123456public class HelloAction1 &#123; public String sayHello() &#123; System.out.println("Hello action 调用"); return "success"; &#125;&#125; 12345&lt;package name="p1" extends="struts-default" namespace="/user1"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction1" method="sayHello"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第二种写法：写一个action类，实现Action接口，overridee execute方法，在struts配置action元素时，不用指定method，因为默认就是执行动作类的execute方法 123456public class HelloAction2 implements Action &#123; @Override public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; struts.xml 12345&lt;package name="p2" extends="struts-default" namespace="/user2"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction2"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第三种写法：写一个action类，继承ActionSupport类（ActionSupport类是实现了Action的类） 1234567import com.opensymphony.xwork2.ActionSupport;public class HelloAction3 extends ActionSupport &#123; public String login()&#123; return SUCCESS; &#125;&#125; struts.xml 12345&lt;package name="p3" extends="struts-default" namespace="/user3"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction3" method="login"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 默认的动作类：就是当配置了一个action元素，但是没有指定class，也没有指定method，那么就会默认找ActionSupport类去处理这个请求。由于由于struts.xml是在struts-default.xml后加载的，因此默认的动作类是可以修改，可以修改成自己写的类。 在package元素下配置一个default-class-ref，class指定自己的动作类。 1&lt;default-class-ref class="cn.zhuobo.web.action.HelloAction1"&gt;&lt;/default-class-ref&gt; 动作访问的通配符： 当实现用户的增删改查的时候，可以在一个UserAction里写add、delete、update、find的方法分别实现，这个时候的动作类可以是类似以下的类的定义： 123456789101112131415161718public class UserAction extends ActionSupport &#123; // 添加用户 public String add()&#123; return SUCCESS; &#125; // 删除用户 public String delete()&#123; return SUCCESS; &#125; // 更新用户 public String update()&#123; return SUCCESS; &#125; // 查询用户 public String find()&#123; return SUCCESS; &#125;&#125; 但是，当配置struts.xml的时候就会发现配置比较麻烦，对于这几个功能的配置应该如下。可以看出来要为每一个功能配置一个action元素，而且很多重复性的工作，比如每一个action都是同一个class，name、method、xxx.jsp其实都是同名的。 123456789101112131415161718&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;!-- 添加用户的动作 --&gt; &lt;action name="add" class="cn.zhuobo.web.action.UserAction" method="add"&gt; &lt;result name="success"&gt;/add.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 删除用户的动作 --&gt; &lt;action name="delete" class="cn.zhuobo.web.action.UserAction" method="delete"&gt; &lt;result name="success"&gt;/delete.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 更新用户的动作 --&gt; &lt;action name="update" class="cn.zhuobo.web.action.UserAction" method="update"&gt; &lt;result name="success"&gt;/update.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 查询用户的动作 --&gt; &lt;action name="find" class="cn.zhuobo.web.action.UserAction" method="find"&gt; &lt;result name="success"&gt;/find.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 可以使用通配符是简化这种配置，使用通配符后配置应该如下： {1}：代表这是第一个通配符* 12345&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;action name="*" class="cn.zhuobo.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 如果是定义了一个动作类如下，可以使用两个通配符*： 1234567891011public class StudentAction extends ActionSupport &#123; // add student public String addStudent() &#123; return SUCCESS; &#125; // delete student public String deleteStudent() &#123; return SUCCESS; &#125;&#125; struts.xml 12345&lt;package name="studentPackage" extends="struts-default" namespace="/student"&gt; &lt;action name="*_*" class="cn.zhuobo.web.action.StudentAction" method="&#123;1&#125;&#123;2&#125;"&gt; &lt;result name="success"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 当访问 http://localhost/student/add_Student，便可以执行响应的动作类的方法。 使用绝对的匹配和通配符的方法匹配，当两种方法都使用的时候，绝对匹配的优先，通配符的方法，根据在配置文件的位置顺序优先。 4. result元素作用：为动作指定结果视图 属性：name、type name：逻辑视图的名称，对应着动作的方法的返回值，默认是 success type：结果类型，指的是用什么方法跳转到指定的页面，默认是 dispatcher type的取值： type取值 作用 dispatcher 默认值，使用请求转发，转发到一个页面 redirect 使用重定向，转向一个页面 chain 转发到另一个action，可以是同一个包或者是不同一个包 redirectAction 重定向到另一个action，可以是同一个包或者不同一个包 dispatcher和redirect是用于对页面的请求转发和重定向的，而chain和redirectAction是用于对action的请求转发和重定向的。下面是配置的方法： dispatcher、redirect 123456789&lt;!-- 默认是dispatcher --&gt;&lt;action name="*_*" class="cn.zhuobo.web.action.StudentAction" method="&#123;1&#125;&#123;2&#125;"&gt; &lt;result name="success"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt;&lt;!-- redirect--&gt;&lt;action name="*_*" class="cn.zhuobo.web.action.StudentAction" method="&#123;1&#125;&#123;2&#125;"&gt; &lt;result name="success" type="redirect"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt; chain、redirectAction 12345678910111213141516&lt;!-- 转发或者重定向到同一个包的action --&gt;&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;action name="*" class="cn.zhuobo.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success" type="chain"&gt;action2&lt;/result&gt; &lt;/action&gt;&lt;/package&gt;&lt;!-- 转发或者重定向到另一个包的action，需要添加参数param元素 --&gt;&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;action name="*" class="cn.zhuobo.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success" type="chain"&gt; &lt;param name="namespace"&gt;/student&lt;/param&gt; &lt;param name="actionName"&gt;&#123;1&#125;_Student&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 5. 自定义一个结果视图（result的type类型）结果类型就是一个类，这些结果类型的类都是实现了 com.opensymphony.xwork2.Result接口，或者是继承了这个接口的实现类 org.apache.struts2.dispatcher.StrutsResultSupport。这些类都有一个 doExecute方法，用于执行结果视图。struts的内部本质上就是一个servlet，因此可以自定义一个结果视图，只要提供实现 Result接口，复写doExecute方法即可。下面举一个用于输出验证码的结果类型的例子： 定义一个类 CAPTCHAResult类，继承 StrutsResultSupport类，在类里面覆盖重写 doExecute方法，该方法的逻辑就是生成验证码 –&gt; 写回验证码到客户端 12345678910111213141516public class CAPTCHAResult extends StrutsResultSupport &#123; private int width; private int height; // 这里提供width和height的getter和setter方法，用于给struts注入参数 @Override protected void doExecute(String s, ActionInvocation actionInvocation) throws Exception &#123; // 1. 创建一个验证码，高度、验证码个数、线条数 ValidateCode code = new ValidateCode(width, height, 4, 8); // 2. 获取response对象 HttpServletResponse response = ServletActionContext.getResponse(); // 3. 写回给客户端 code.write(response.getOutputStream()); &#125;&#125; ValidateCode是一个生成验证码的小框架。 配置struts.xml文件 123456789101112131415&lt;!-- 在这个包里声明一个验证码的结果类型--&gt;&lt;package name="p" extends="struts-default" namespace="/n"&gt; &lt;!-- 在这里声明了一个局部的结果视图，就仅仅可在这个包里使用--&gt; &lt;result-types&gt; &lt;result-type name="captcha" class="cn.zhuob.web.result.CAPTCHAResult"&gt;&lt;/result-type&gt; &lt;/result-types&gt; &lt;action name="checkcode"&gt; &lt;result name="success" type="captcha"&gt; &lt;!--使用param元素为结果类注入参数--&gt; &lt;param name="width"&gt;200&lt;/param&gt; &lt;param name="height"&gt;40&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt; result元素里的param子元素：如果在动作类中有与param的name相同的属性，struts会自动请求参数并将参数值通过setter方法设置到类的同名属性中。 展示：访问 http://localhost/n/checkcode 6. 局部结果视图和全局的结果视图按照前面定义的结果视图，是一个局部视图，只能在包内访问，在另一个包是不能访问的。要使不同的包都可以访问同一个视图，那么就要定义为全局视图。参考抽取一个BaseServlet，在BaseServlet的service方法里完成方法的分发，让其他的servlet继承BaseServlet的方法。这里也可以定义一个抽象的包，在这个抽象的包里定义一个结果视图，其他的包继承这个抽象包便都可以访问这个结果视图。 抽象包：没有action元素，用来继承 123456789101112&lt;package name="myDefault" extends="struts-default" abstract="true"&gt; &lt;result-types&gt; &lt;result-type name="captcha" class="cn.zhuob.web.result.CAPTCHAResult"&gt;&lt;/result-type&gt; &lt;/result-types&gt; &lt;global-results&gt; &lt;result name="success" type="captcha"&gt; &lt;param name="width"&gt;500&lt;/param&gt; &lt;param name="height"&gt;100&lt;/param&gt; &lt;/result&gt; &lt;/global-results&gt;&lt;/package&gt; 要访问全局视图的包：继承包myDefault 123&lt;package name="p" extends="myDefault" namespace="/n"&gt; &lt;action name="checkcode"&gt;&lt;/action&gt;&lt;/package&gt; 六、获取Servlet的request、response等对象1. 通过ServletActionContext类获取12345678910111213141516171819public class TestAction extends ActionSupport &#123; public String test() &#123; // 获取request、response、session、application // 1. 通过ServletActionContext获取 HttpServletRequest request = ServletActionContext.getRequest(); // StrutsRequestWrapper --&gt; 属于struts，是HttpServletRequest的实现类 HttpServletResponse response = ServletActionContext.getResponse(); // ResponseFacade --&gt; 属于tomcat，是HttpServletResponse的实现类 HttpSession session = request.getSession(); // StandardSessionFacade --&gt; 属于tomcat，是HttpSession的实现类 ServletContext application = ServletActionContext.getServletContext(); // ApplicationContextFacade --&gt; 属于tomcat return NONE; &#125;&#125; 2. 通过注入的方法，要实现XXXAware接口123456789101112131415161718192021222324252627282930313233public class TestAction extends ActionSupport implements ServletRequestAware, ServletResponseAware, ServletContextAware &#123; private HttpServletResponse response; private HttpServletRequest request; private ServletContext application; public String test() &#123; System.out.println(request); System.out.println(response); System.out.println(application); return NONE; &#125; @Override public void setServletRequest(HttpServletRequest httpServletRequest) &#123; this.request = httpServletRequest; System.out.println("注入" + this.request); &#125; @Override public void setServletResponse(HttpServletResponse httpServletResponse) &#123; this.response = httpServletResponse; System.out.println("注入" + this.response); &#125; @Override public void setServletContext(ServletContext servletContext) &#123; this.application = servletContext; System.out.println("注入" + this.application); &#125;&#125; 这种通过注入的方法是由struts的拦截器实现的。根据前面的struts结构图，要访问Action首先要经历一系列的拦截器（Interceptor），拦截器首先会对被访问的action对象作出一些处理。在这种获取方式里，&lt; interceptor name=&quot;servletConfig&quot;class=&quot;org.apache.struts2.interceptor.ServletConfigInterceptor&quot;/&gt;这个拦截器将调用上面的三个方法注入。查看 ServletConfigInterceptor的源码： 访问action前要先访问拦截器，ServletConfigInterceptor拦截器的主要作用是获取要被访问的action，然后判断是否实现了 ServletRequestAware、ServletResponseAware、ServletContextAware等接口，如果实现了获取相应的HttpServletRequest、HttpServletResponse、ServletContext，然后调用Action的setter方法注入。 七、多个struts.xml的配置当开发的功能越来越多，应用的规模越来越复杂，随着action的增加，struts.xml不可避免的变得越来越臃肿，而且还不利于模块分工的开发。为了增加struts.xml的可读性、利于模块开发、减少冲突，可以将struts.xml分解为多个配置文件，典型的就是根据功能模块去划分。比如，当应用可以分为user、order、pay三个功能，都在同一个struts.xml中配置会是这种形式： struts.xml 1234567891011121314&lt;!-- user模块--&gt;&lt;package name="p1" extends="struts-default" namespace="/user"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt;&lt;!-- order模块--&gt;&lt;package name="p2" extends="struts-default" namespace="/order"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt;&lt;!-- pay模块--&gt;&lt;package name="p3" extends="struts-default" namespace="/pay"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; 当采取划分多个为多个配置文件的方式，只需要每个模块分别写自己的配置文件，在struts.xml中包含这些配置文件即可。 struts-user.xml 1234&lt;!-- user模块--&gt;&lt;package name="p1" extends="struts-default" namespace="/user"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; struts-order.xml 1234&lt;!-- order模块--&gt;&lt;package name="p2" extends="struts-default" namespace="/order"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; struts-pay.xml 1234&lt;!-- pay模块--&gt;&lt;package name="p3" extends="struts-default" namespace="/pay"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; 然后再struts.xml中包含以上3个xml 123&lt;include file="struts-user.xml"&gt;&lt;/include&gt;&lt;include file="struts-order.xml"&gt;&lt;/include&gt;&lt;include file="struts-pay.xml"&gt;&lt;/include&gt; 八、Action接收请求参数1. 通过servlet获取，先获取request对象1234567891011public class LoginAction extends ActionSupport &#123; public String login() &#123; HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter("username"); String password = request.getParameter("password"); System.out.println(username); System.out.println(password); return NONE; &#125;&#125; 2. 通过Action属性的setter方法注入在访问action之前，拦截器先获取action，判断Action类是否有password和username属性，如果有就调用对应的setter方法为属性注入值。 123456789101112131415161718192021public class LoginAction extends ActionSupport &#123; private String password; private String username; public void setPassword(String password) &#123; System.out.println("set password"); this.password = password; &#125; public void setUsername(String username) &#123; System.out.println("set username"); this.username = username; &#125; public String login() &#123; System.out.println(username); System.out.println(password); return NONE; &#125;&#125; 3. 通过Action属性的模型注入其实也就是不分别注入username、password，Action类提供的是User成员变量，而User有username和password这两个成员变量。还是一样的过程，拦截器首先判断Action类是否有user这个属性，如果有就调用setUser方法注入参数。 提交的表单：注意name的值是user.username、user.password 12345&lt;form action="$&#123;pageContext.request.contextPath&#125;/login.do"&gt; username:&lt;input type="text" name="user.username"&gt; password:&lt;input type="password" name="user.password"&gt; &lt;input type="submit" value="登录"&gt;&lt;/form&gt; LoginAction：提供setUser、getUser方法 123456789101112131415161718public class LoginAction extends ActionSupport &#123; private User user; public void setUser(User user) &#123; System.out.println("set user"); this.user = user; &#125; public User getUser() &#123; System.out.println("get user"); return this.user; &#125; public String login() &#123; System.out.println(user); return NONE; &#125;&#125; 根据输出结果：getUser方法执行了2次，setter方法执行了1次，过程是：tomcat服务器创建Action实例，得到Action的具体信息，成员变量User、成员方法setter、getter，然后tomcat执行拦截器的内容，也就是判断是否有user这个属性，那么就调用setUser注入参数。过程如下：1. 首先调用getUser发现user为null；2. new 一个Use；3. 调用setUser设置user为new出来的user；3. 设置password；4. getUser，获取user去设置username 4. Action的模型驱动封装参数这个工作也是一个拦截器做了，这个拦截器叫模型驱动拦截器 com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor，它不会创建模型，因此Action提供的模型属性要自己new出来赋值。 Action实现一个 ModelDriven&lt;User&gt;接口，覆盖重写 getModel方法； Action提供一个模型属性，并且要赋值； 这种方法，表单的name就不用写user. Action: 12345678910111213public class LoginAction extends ActionSupport implements ModelDriven&lt;User&gt; &#123; private User user = new User();// user 要赋值！！ public String login() &#123; System.out.println(user); return NONE; &#125; @Override public User getModel() &#123; return user; &#125;&#125; 表单： 12345&lt;form action="$&#123;pageContext.request.contextPath&#125;/login.do"&gt; username:&lt;input type="text" name="username"&gt; password:&lt;input type="password" name="password"&gt; &lt;input type="submit" value="登录"&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lunix基础]]></title>
    <url>%2F2019%2F05%2F28%2FLunix%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、linux的应用领域 基于linux的企业服务器：很多公司使用Linux作为服务端系统 嵌入式应用：安卓、智能家居、银行系统等 Linux在电影娱乐业的应用 二、常用命令命令基本格式：命令 [-选项] [参数]，例如：ls -la /usr 当有多个选项，可以写在一起 1. 目录、文件处理命令 ls：-l（long，显示详细信息）；-h（human，大小按kb、MB显示）；-a（显示隐藏文件）；-d（显示目录本身而非目录下文件的信息） mkdir：-p（递归创建，可以创建中间尚未存在的目录） pwd：打印当前目录的路径 rmdir：删除空目录；-r（） cp：cp 源文件 目标目录；-p（保存文件的属性，如修改时间等）；-r（复制目录）； mv：移动，移动目录不用加-r选项 rm：-r（删除目录）；-f（强制删除）； touch：创建文件 cat：查看文件；-n（查看的时候可以显示行号） more：查看文件，回车（翻页）；空格（换行）；q（退出） less：查看文件，可以向上翻页 head：查看文件 hean -n 20 filename（查看前20行） tail：和head类似，查看文件末尾 2. 更改文件权限 chmod：读r、写w、执行x三种权限用数字4、2、1表示，如 chmod 777 filename，表示所有用户拥有所有权限 权限对于文件和目录的含义不同：对于文件来说写w是修改文件，对于目录来说写w是在目录里创建删除目录（文件） chown：改变文件的所有者。chown 用户 文件或者目录（将文件的所有这改为新的所有者） chgrp：改变文件的所属组。chown 用户组 文件或者目录； umask：查看默认的创建文件、目录的权限 3. 文件搜索命令 find：find [搜索范围] [匹配条件] -name：匹配条件为文件名，*匹配任意字符串，？匹配任意单个字符，find /etc -name init -iname：不区分大小写的文件名 -size：+n（文件大小大于），-n（文件大小小于），=n（文件大小等于） -amin：匹配条件为访问时间，在/etc目录下查找5分钟内被访问过的文件 find /etc -amin -5 -mmin：匹配条件为修改时间，在/etc目录下查找30分钟内被修改过的文件 `find /etc -mmin -30 -type：匹配条件为文件类型，f表示文件，d表示目录 -a：当有多个查询条件时，使用-a连接，表示and -o：当有多个查询条件时，使用-o连接，表示or locate：类似于everything -i：不区分大小写 updatdb：更新文件资料库 grep：在文件内容中查找 sudo grep mysql /root/install.log -v：排除包含指定字符的行，如排除以#开始的行（也就是注释行）grep -v ^# mysql /root/install.log man：命令的帮助信息 man ls：查看ls的帮助信息 4.关机重启命令 shutdown：-r(重启)、-h(重启)、-c(取消前一个关机重启命令) #### 5. 打包压缩命令 打包压缩为.tar.gz tar -zcvf 打包压缩后的文件名 要打包压缩的文件 tar -zcvf xxx1.tar.gz a.txt b.python c.cpp dir1 dir2 tar -zcvf /usr/* 解压缩，-C 加解压后文件的位置 tar -xvf 压缩包 tar -xvf xxx.tar.gz(解压缩后放在当前目录) tar -xvf xxx.tar.gz -C ~/Desktop(解压缩后放在Desktop) zip压缩解压缩 压缩：zip -r xxx.zip ./*，将当前录下所有文件包括目录压缩为xxx.zip 解压缩：unzip -o -d ~/Desktop/dir xxx.zip，将xxx.zip解压到桌面下的dir目录，并且重复了（-o）也不提示就覆盖 5. vim常用操作、技巧 常用操作 插入命令： 命令 插入位置 i 在光标所在字符前插入 I 在光标所在行首插入 o 在光标下一行插入新行 O 在光标下一行插入新行 a 在光标所在字符后插入 A 在光标所在行尾插入 定位命令： 命令 作用 ：set nu 设置行号 ：set nonu 取消行号 x 删除光标所在处字符 nx 删除光标所在处后n个字符 dd 删除光标所在行 ndd 删除n行 D 删除光标所在处到行尾内容 复制剪切命令： 命令 作用 yy 复制当前行 nyy 复制当前行以下n行 dd 剪切当前行 ndd 剪切当前行以下n行 p、P 粘贴在当前行上、或者行下 取消和替换： 命令 作用 u 取消上一步操作 R 从光标所在处开始替换，知道按esc r 替换光标所在字符 查找： 命令 作用 /string 搜索指定字符串，如果要忽略大小写先输入命令 :set ic 退出和保存： 命令 作用 :w 保存修改 :w new_filename 另存为新文件 :wq 保存修改并退出 :q! 不保存修改退出 ZZ 快捷键，保存修改并退出]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F05%2F28%2FRedis%2F</url>
    <content type="text"><![CDATA[一、概念Redis是一款高性能的NOSQL系列（NoSQL = Not Only SQL ）的数据库 1.1.什么是NOSQL​ NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。​ 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 ​ 1.1.1. NOSQL和关系型数据库比较​ 优点：​ 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。​ 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。​ 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。​ 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 ​ 缺点：​ 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。​ 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。​ 3）不提供关系型数据库对事务的处理。 ​ 1.1.2. 非关系型数据库的优势： ​ 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。​ 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 ​ 1.1.3. 关系型数据库的优势：​ 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。​ 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 ​ 1.1.4. 总结​ 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，​ 让NoSQL数据库对关系型数据库的不足进行弥补。​ 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品​ • 键值(Key-Value)存储数据库​ 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB​ 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。​ 数据模型： 一系列键值对​ 优势： 快速查询​ 劣势： 存储的数据缺少结构化​ • 列存储数据库​ 相关产品：Cassandra, HBase, Riak​ 典型应用：分布式的文件系统​ 数据模型：以列簇式存储，将同一列数据存在一起​ 优势：查找速度快，可扩展性强，更容易进行分布式扩展​ 劣势：功能相对局限​ • 文档型数据库​ 相关产品：CouchDB、MongoDB​ 典型应用：Web应用（与Key-Value类似，Value是结构化的）​ 数据模型： 一系列键值对​ 优势：数据结构要求不严格​ 劣势： 查询性能不高，而且缺乏统一的查询语法​ • 图形(Graph)数据库​ 相关数据库：Neo4J、InfoGrid、Infinite Graph​ 典型应用：社交网络​ 数据模型：图结构​ 优势：利用图结构相关算法。​ 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis​ Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：​ 1) 字符串类型 string​ 2) 哈希类型 hash​ 3) 列表类型 list​ 4) 集合类型 set​ 5) 有序集合类型 sortedset​ 1.3.1 redis的应用场景​ • 缓存（数据查询、短连接、新闻内容、商品内容等等）​ • 聊天室的在线好友列表​ • 任务队列。（秒杀、抢购、12306等等）​ • 应用排行榜​ • 网站访问统计​ • 数据过期处理（可以精确到毫秒​ • 分布式集群架构中的session分离 二、命令操作1. Redis的数据结构Redis存储的是键值对，key都是字符串，value可以有5种不同的类型数据： 字符串 string 哈希类型 hash：map格式，可以存储键值对 列表类型 list：linkedlist格式，元素可以重复 集合类型 set 元素不可以重复 有序集合类型 sortedset 元素可以重复而且有序 2. Redis命令操作 字符串string 存储：set key value 获取：get key 删除：del key 哈希类型 hash 存储：hset key field value 获取： hget key field：获取指定的field对应的值 hgetall key：获取所有的field和value 删除：hdel key field 1234hset myhash username Tomhset myhash age 18hget myhash age -- 18 列表类型 list：可以添加一个元素到列表的头部（左）或者尾部（右） 存储： lpush key value：将元素加入列表左边 rpush key value：将元素加入列表右边 获取： lrange key start end：范围获取 删除： lpop：删除最左边元素，并返回该元素 rpop：删除最右边元素，并返回该元素 12345lpush mylist alpush mylist blpush mylist c -- a-&gt;b-&gt;clrange mylist 0 -1 -- 获取mylist所有的元素 集合类型 set 存储：sadd key value 获取：smembers key：获取集合中所有的元素 删除：srem key value：删除集合中某个元素 有序集合类型 sortedset 存储：zadd key score value 获取：zrange key start end（withscores） 删除：zrem key value 1234567891011 127.0.0.1:6379&gt;zadd sorted 10 aaa(integer) 1127.0.0.1:6379&gt; zadd sorted 30 bbb(integer) 1127.0.0.1:6379&gt; zadd sorted 20 ccc(integer) 1127.0.0.1:6379&gt; zrange sorted 0 -1// 按照分数（score）排序1) &quot;aaa&quot;2) &quot;ccc&quot;3) &quot;bbb&quot; 常用的通用命令： keys *：查询所有的键 type key：获取键对应的value的类型 del key：删除指定的key以及该key对应的value 三、Redis持久化Redis是一个基于内存的数据库，因此当Redis服务器重启会导致数据丢失，可以将Redis数据库的数据存储到硬盘。 1. Redis持久化机制 RDB: 默认方式，不需要进行配置，默认使用的机制，在一定的时间间隔内，检测key的变化情况，然后持久化数据 编辑配置文件：redis.windows.conf 1234567# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changedsave 900 1save 300 10save 60 10000 重新启动Redis服务器，并且指定配置文件:$ redis-server.exe redis.windows.conf AOF: 记录日志的方式，可以记录每一条操作的命令，操作命令后就持久化数据（这样的效果和mysql类似了） 编辑配置文件：redis.windows.conf 12345678# 开启aof模式appendonly no --&gt; appendonly yes# aof模式下的三种持久化方式# appendfsync always # 总是，每一条操作都持久化appendfsync everysec # 每间隔1s进行一次持久化# appendfsync no # 不进行持久化 四、Java客户端Jedis Jedis是一款java操作Redis数据库的工具，类似于JDBC 使用步骤： 下载、导入jar包 使用 使用Demo 12345678910111213141516@Testpublic void test2() &#123; // 获取连接, 如果使用的是空参数的构造，那么默认就是localhost和6379 Jedis jedis = new Jedis("localhost", 6379); // 操作 jedis.set("username", "David"); String username = jedis.get("username"); System.out.println(username);// David // 可以使用方法setex来存储指定的过期时间的key value jedis.setex("activeCode", 20, "didi");// 20秒后键activeCode、值didi就被自动删除 // 关闭连接 jedis.close();&#125; Jedis连接池 12345678910111213141516171819@Testpublic void test5() &#123; // 创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50);// 最大的允许连接数量 config.setMaxIdle(10);// 最大的空闲连接数 // 创建一个JedisPool连接池对象 JedisPool jedisPool = new JedisPool(config, "localhost", 6379); // 获取连接 Jedis jedis = jedisPool.getResource(); // 使用 jedis.set("username", "Tom"); // 归还连接给连接池 jedis.close();&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
</search>
