<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[struts问题总结]]></title>
    <url>%2F2019%2F05%2F31%2Fstruts%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在使用struts2框架的过程中遇到的一些问题的总结： 1. 异常Error setting expression ‘xxx’ with value… 在提交表单的时候遇到的这个问题，其实并不影响应用的运行，但是也还是个异常，根据提示可以发现是 Developer Notification，也就是在struts.xml配置了开发模式，才会提醒这个信息，关闭开发模式便不会提醒。但是问题的根本应该是表单对应的参数，比如username和password在Action类里没有提供对应的setter和getter方法，在Action类中提供了便不会有这个异常的提示。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2]]></title>
    <url>%2F2019%2F05%2F29%2Fstruts2%2F</url>
    <content type="text"><![CDATA[一、介绍Struts2是Apache发行MVC开源框架，也就是表现层框架。MVC包括： M：Model，用于封装数据，javabean V：View，用于展示数据，jsp C：Controller，控制程序的流程，servlet、filter 二、使用 创建一个javaweb项目，导入Struts2的相关jar包 在src目录下创建 struts.xml,配置如下 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt;&lt;!-- package表示包 name：包名 extends：继承，默认是struts-default action:动作 name：相当于servlet的映射路径 class：处理请求的类,相当于一个servlet method：处理请求的方法 result：结果，写返回的jsp页面--&gt;&lt;package name="p1" extends="struts-default"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction" method="sayHello"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt;&lt;/struts&gt; 编写一个类，用于处理请求（相当于servlet），类里编写一个方法，返回一个String 12345678package cn.zhuobo.web.action;public class HelloAction &#123; public String sayHello() &#123; System.out.println("Hello action 调用"); return "success"; &#125;&#125; 新建一个jsp页面 123&lt;body&gt;由helloaction返回的jsp页面&lt;/body&gt; 访问hello：http://localhost/hello 三、处理的过程 浏览器请求资源hello，服务器收到请求 在 struts.xml匹配 name=&#39;hello&#39;的标签，由此将请求交给对应的class、class里的method处理 根据method指定的方法返回的字符串 “success” 找到对应name为success的result标签，将success.jsp转为静态页面响应回客户端 struts流程图： struts架构图，解释了struts处理请求的过程 四、struts配置文件加载的顺序 加载顺序 顺 序 配置文件名 所在位置 说明 1 default.properties struts2-core-2.3.15.3.jar\org\apache\struts2 不能修改 2 struts-default.xml struts2-core-2.3.15.3.jar 不能修改 3 strtuts-plugin.xml 在struts2提供的插件jar包中 不能修改 4 struts.xml 我们的应用中 可以修改的：推荐 5 struts.properties 我们的应用中 可以修改的 6 web.xml 我们的应用中 可以修改的，可以给过滤器配置参数 后加载的配置文件可以覆盖前面的配置文件； default.properties的一些默认的配置信息 配置 作用 struts.i18n.encoding=UTF-8 使用编码集为UTF-8 struts.action.extension=action,, 默认访问的扩展后缀为.action或者空（没有后缀） struts.devMode = false 开发者模式默认关闭，设置为true在出错的时候可以显示更加详细 修改访问后缀的三种方式，要注意的是以下一旦配置了就会覆盖default.properties的后缀action或者空后缀 方法1：在struts.xml中配置 &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do&quot;&gt;&lt;/constant&gt; 方法2：在src下创建配置文件，名为struts.properties，文件内容为 struts.action.extension=do 方法3：在web.xml中配置如下，后缀为ddd 123456789&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;struts.action.extension&lt;/param-name&gt; &lt;param-value&gt;ddd&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; 配置为开发模式：在struts.xml中配置一个常量，显示更为详细的错误新仙尼 &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot;&gt;&lt;/constant&gt; 五、struts.xml配置文件的元素1. package元素，表示包，相关属性如下 属性 作用 name 包名，必须的属性，并且是在struts配置中包名要唯一 extends 继承，表示继承的包，一般都要继承 struts-default，该包邮转发、重定向等功能，继承这个包可以使用struts的核心功能 abstract 抽象，值为true表示这个包是抽象的，可以用来被其他的包继承，只要这个包没有action元素都可以被声明为抽象的 namespace 命名空间，访问路径 = 命名空间 + 动作名 2. namespace的查找规则namespace的默认值是一个空字符串，如果配置的值为 /user（注意要加/斜杠），那么访问路径就是 user/helloAcion.do 12345&lt;package name="p1" extends="struts-default" namespace="/user"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction" method="sayHello"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 如果访问的是：http://localhost:8080/demo1/a/b/user/hello.action 首先查找是否还有package的namespace为 /a/b/user 如果有，就访问这个包里的对应的hello.action 如果没有，就查找是否有namespace为 /a/b的包，依次类推 因此如果有一个package的namespace值为 /user，(如上面的配置)，那么http://localhost:8080/demo1/a/b/user/hello.action是不可以访问到hello.action的，但是http://localhost:8080/demo1/user/a/b/hello.action是可以访问到hello.action的，因为最后会查找到是否有 /user 这个命名空间，然后访问该包下的action。 3. action元素，用于配置动作，处理请求路径，属性如下： 属性 作用 name 动作名，相当于servlet的映射路径 class 动作类的全类名，是处理请求的类，相当于一个servlet method 动作类里处理请求的方法 动作类有3中写法： 第一种写法：直接写一个action类，然后再struts.xml里配置 123456public class HelloAction1 &#123; public String sayHello() &#123; System.out.println("Hello action 调用"); return "success"; &#125;&#125; 12345&lt;package name="p1" extends="struts-default" namespace="/user1"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction1" method="sayHello"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第二种写法：写一个action类，实现Action接口，overridee execute方法，在struts配置action元素时，不用指定method，因为默认就是执行动作类的execute方法 123456public class HelloAction2 implements Action &#123; @Override public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; struts.xml 12345&lt;package name="p2" extends="struts-default" namespace="/user2"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction2"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 第三种写法：写一个action类，继承ActionSupport类（ActionSupport类是实现了Action的类） 1234567import com.opensymphony.xwork2.ActionSupport;public class HelloAction3 extends ActionSupport &#123; public String login()&#123; return SUCCESS; &#125;&#125; struts.xml 12345&lt;package name="p3" extends="struts-default" namespace="/user3"&gt; &lt;action name="hello" class="cn.zhuobo.web.action.HelloAction3" method="login"&gt; &lt;result name="success"&gt;/success.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 默认的动作类：就是当配置了一个action元素，但是没有指定class，也没有指定method，那么就会默认找ActionSupport类去处理这个请求。由于由于struts.xml是在struts-default.xml后加载的，因此默认的动作类是可以修改，可以修改成自己写的类。 在package元素下配置一个default-class-ref，class指定自己的动作类。 1&lt;default-class-ref class="cn.zhuobo.web.action.HelloAction1"&gt;&lt;/default-class-ref&gt; 动作访问的通配符： 当实现用户的增删改查的时候，可以在一个UserAction里写add、delete、update、find的方法分别实现，这个时候的动作类可以是类似以下的类的定义： 123456789101112131415161718public class UserAction extends ActionSupport &#123; // 添加用户 public String add()&#123; return SUCCESS; &#125; // 删除用户 public String delete()&#123; return SUCCESS; &#125; // 更新用户 public String update()&#123; return SUCCESS; &#125; // 查询用户 public String find()&#123; return SUCCESS; &#125;&#125; 但是，当配置struts.xml的时候就会发现配置比较麻烦，对于这几个功能的配置应该如下。可以看出来要为每一个功能配置一个action元素，而且很多重复性的工作，比如每一个action都是同一个class，name、method、xxx.jsp其实都是同名的。 123456789101112131415161718&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;!-- 添加用户的动作 --&gt; &lt;action name="add" class="cn.zhuobo.web.action.UserAction" method="add"&gt; &lt;result name="success"&gt;/add.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 删除用户的动作 --&gt; &lt;action name="delete" class="cn.zhuobo.web.action.UserAction" method="delete"&gt; &lt;result name="success"&gt;/delete.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 更新用户的动作 --&gt; &lt;action name="update" class="cn.zhuobo.web.action.UserAction" method="update"&gt; &lt;result name="success"&gt;/update.jsp&lt;/result&gt; &lt;/action&gt; &lt;!-- 查询用户的动作 --&gt; &lt;action name="find" class="cn.zhuobo.web.action.UserAction" method="find"&gt; &lt;result name="success"&gt;/find.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 可以使用通配符是简化这种配置，使用通配符后配置应该如下： {1}：代表这是第一个通配符* 12345&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;action name="*" class="cn.zhuobo.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success"&gt;/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 如果是定义了一个动作类如下，可以使用两个通配符*： 1234567891011public class StudentAction extends ActionSupport &#123; // add student public String addStudent() &#123; return SUCCESS; &#125; // delete student public String deleteStudent() &#123; return SUCCESS; &#125;&#125; struts.xml 12345&lt;package name="studentPackage" extends="struts-default" namespace="/student"&gt; &lt;action name="*_*" class="cn.zhuobo.web.action.StudentAction" method="&#123;1&#125;&#123;2&#125;"&gt; &lt;result name="success"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 当访问 http://localhost/student/add_Student，便可以执行响应的动作类的方法。 使用绝对的匹配和通配符的方法匹配，当两种方法都使用的时候，绝对匹配的优先，通配符的方法，根据在配置文件的位置顺序优先。 4. result元素作用：为动作指定结果视图 属性：name、type name：逻辑视图的名称，对应着动作的方法的返回值，默认是 success type：结果类型，指的是用什么方法跳转到指定的页面，默认是 dispatcher type的取值： type取值 作用 dispatcher 默认值，使用请求转发，转发到一个页面 redirect 使用重定向，转向一个页面 chain 转发到另一个action，可以是同一个包或者是不同一个包 redirectAction 重定向到另一个action，可以是同一个包或者不同一个包 dispatcher和redirect是用于对页面的请求转发和重定向的，而chain和redirectAction是用于对action的请求转发和重定向的。下面是配置的方法： dispatcher、redirect 123456789&lt;!-- 默认是dispatcher --&gt;&lt;action name="*_*" class="cn.zhuobo.web.action.StudentAction" method="&#123;1&#125;&#123;2&#125;"&gt; &lt;result name="success"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt;&lt;!-- redirect--&gt;&lt;action name="*_*" class="cn.zhuobo.web.action.StudentAction" method="&#123;1&#125;&#123;2&#125;"&gt; &lt;result name="success" type="redirect"&gt;/&#123;2&#125;/&#123;1&#125;.jsp&lt;/result&gt;&lt;/action&gt; chain、redirectAction 12345678910111213141516&lt;!-- 转发或者重定向到同一个包的action --&gt;&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;action name="*" class="cn.zhuobo.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success" type="chain"&gt;action2&lt;/result&gt; &lt;/action&gt;&lt;/package&gt;&lt;!-- 转发或者重定向到另一个包的action，需要添加参数param元素 --&gt;&lt;package name="userPackage" extends="struts-default" namespace="/user"&gt; &lt;action name="*" class="cn.zhuobo.web.action.UserAction" method="&#123;1&#125;"&gt; &lt;result name="success" type="chain"&gt; &lt;param name="namespace"&gt;/student&lt;/param&gt; &lt;param name="actionName"&gt;&#123;1&#125;_Student&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 5. 自定义一个结果视图（result的type类型）结果类型就是一个类，这些结果类型的类都是实现了 com.opensymphony.xwork2.Result接口，或者是继承了这个接口的实现类 org.apache.struts2.dispatcher.StrutsResultSupport。这些类都有一个 doExecute方法，用于执行结果视图。struts的内部本质上就是一个servlet，因此可以自定义一个结果视图，只要提供实现 Result接口，复写doExecute方法即可。下面举一个用于输出验证码的结果类型的例子： 定义一个类 CAPTCHAResult类，继承 StrutsResultSupport类，在类里面覆盖重写 doExecute方法，该方法的逻辑就是生成验证码 –&gt; 写回验证码到客户端 12345678910111213141516public class CAPTCHAResult extends StrutsResultSupport &#123; private int width; private int height; // 这里提供width和height的getter和setter方法，用于给struts注入参数 @Override protected void doExecute(String s, ActionInvocation actionInvocation) throws Exception &#123; // 1. 创建一个验证码，高度、验证码个数、线条数 ValidateCode code = new ValidateCode(width, height, 4, 8); // 2. 获取response对象 HttpServletResponse response = ServletActionContext.getResponse(); // 3. 写回给客户端 code.write(response.getOutputStream()); &#125;&#125; ValidateCode是一个生成验证码的小框架。 配置struts.xml文件 123456789101112131415&lt;!-- 在这个包里声明一个验证码的结果类型--&gt;&lt;package name="p" extends="struts-default" namespace="/n"&gt; &lt;!-- 在这里声明了一个局部的结果视图，就仅仅可在这个包里使用--&gt; &lt;result-types&gt; &lt;result-type name="captcha" class="cn.zhuob.web.result.CAPTCHAResult"&gt;&lt;/result-type&gt; &lt;/result-types&gt; &lt;action name="checkcode"&gt; &lt;result name="success" type="captcha"&gt; &lt;!--使用param元素为结果类注入参数--&gt; &lt;param name="width"&gt;200&lt;/param&gt; &lt;param name="height"&gt;40&lt;/param&gt; &lt;/result&gt; &lt;/action&gt;&lt;/package&gt; result元素里的param子元素：如果在动作类中有与param的name相同的属性，struts会自动请求参数并将参数值通过setter方法设置到类的同名属性中。 展示：访问 http://localhost/n/checkcode 6. 局部结果视图和全局的结果视图按照前面定义的结果视图，是一个局部视图，只能在包内访问，在另一个包是不能访问的。要使不同的包都可以访问同一个视图，那么就要定义为全局视图。参考抽取一个BaseServlet，在BaseServlet的service方法里完成方法的分发，让其他的servlet继承BaseServlet的方法。这里也可以定义一个抽象的包，在这个抽象的包里定义一个结果视图，其他的包继承这个抽象包便都可以访问这个结果视图。 抽象包：没有action元素，用来继承 123456789101112&lt;package name="myDefault" extends="struts-default" abstract="true"&gt; &lt;result-types&gt; &lt;result-type name="captcha" class="cn.zhuob.web.result.CAPTCHAResult"&gt;&lt;/result-type&gt; &lt;/result-types&gt; &lt;global-results&gt; &lt;result name="success" type="captcha"&gt; &lt;param name="width"&gt;500&lt;/param&gt; &lt;param name="height"&gt;100&lt;/param&gt; &lt;/result&gt; &lt;/global-results&gt;&lt;/package&gt; 要访问全局视图的包：继承包myDefault 123&lt;package name="p" extends="myDefault" namespace="/n"&gt; &lt;action name="checkcode"&gt;&lt;/action&gt;&lt;/package&gt; 六、获取Servlet的request、response等对象1. 通过ServletActionContext类获取12345678910111213141516171819public class TestAction extends ActionSupport &#123; public String test() &#123; // 获取request、response、session、application // 1. 通过ServletActionContext获取 HttpServletRequest request = ServletActionContext.getRequest(); // StrutsRequestWrapper --&gt; 属于struts，是HttpServletRequest的实现类 HttpServletResponse response = ServletActionContext.getResponse(); // ResponseFacade --&gt; 属于tomcat，是HttpServletResponse的实现类 HttpSession session = request.getSession(); // StandardSessionFacade --&gt; 属于tomcat，是HttpSession的实现类 ServletContext application = ServletActionContext.getServletContext(); // ApplicationContextFacade --&gt; 属于tomcat return NONE; &#125;&#125; 2. 通过注入的方法，要实现XXXAware接口123456789101112131415161718192021222324252627282930313233public class TestAction extends ActionSupport implements ServletRequestAware, ServletResponseAware, ServletContextAware &#123; private HttpServletResponse response; private HttpServletRequest request; private ServletContext application; public String test() &#123; System.out.println(request); System.out.println(response); System.out.println(application); return NONE; &#125; @Override public void setServletRequest(HttpServletRequest httpServletRequest) &#123; this.request = httpServletRequest; System.out.println("注入" + this.request); &#125; @Override public void setServletResponse(HttpServletResponse httpServletResponse) &#123; this.response = httpServletResponse; System.out.println("注入" + this.response); &#125; @Override public void setServletContext(ServletContext servletContext) &#123; this.application = servletContext; System.out.println("注入" + this.application); &#125;&#125; 这种通过注入的方法是由struts的拦截器实现的。根据前面的struts结构图，要访问Action首先要经历一系列的拦截器（Interceptor），拦截器首先会对被访问的action对象作出一些处理。在这种获取方式里，&lt; interceptor name=&quot;servletConfig&quot;class=&quot;org.apache.struts2.interceptor.ServletConfigInterceptor&quot;/&gt;这个拦截器将调用上面的三个方法注入。查看 ServletConfigInterceptor的源码： 访问action前要先访问拦截器，ServletConfigInterceptor拦截器的主要作用是获取要被访问的action，然后判断是否实现了 ServletRequestAware、ServletResponseAware、ServletContextAware等接口，如果实现了获取相应的HttpServletRequest、HttpServletResponse、ServletContext，然后调用Action的setter方法注入。 七、多个struts.xml的配置当开发的功能越来越多，应用的规模越来越复杂，随着action的增加，struts.xml不可避免的变得越来越臃肿，而且还不利于模块分工的开发。为了增加struts.xml的可读性、利于模块开发、减少冲突，可以将struts.xml分解为多个配置文件，典型的就是根据功能模块去划分。比如，当应用可以分为user、order、pay三个功能，都在同一个struts.xml中配置会是这种形式： struts.xml 1234567891011121314&lt;!-- user模块--&gt;&lt;package name="p1" extends="struts-default" namespace="/user"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt;&lt;!-- order模块--&gt;&lt;package name="p2" extends="struts-default" namespace="/order"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt;&lt;!-- pay模块--&gt;&lt;package name="p3" extends="struts-default" namespace="/pay"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; 当采取划分多个为多个配置文件的方式，只需要每个模块分别写自己的配置文件，在struts.xml中包含这些配置文件即可。 struts-user.xml 1234&lt;!-- user模块--&gt;&lt;package name="p1" extends="struts-default" namespace="/user"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; struts-order.xml 1234&lt;!-- order模块--&gt;&lt;package name="p2" extends="struts-default" namespace="/order"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; struts-pay.xml 1234&lt;!-- pay模块--&gt;&lt;package name="p3" extends="struts-default" namespace="/pay"&gt; &lt;action name=""&gt;&lt;/action&gt;&lt;/package&gt; 然后再struts.xml中包含以上3个xml 123&lt;include file="struts-user.xml"&gt;&lt;/include&gt;&lt;include file="struts-order.xml"&gt;&lt;/include&gt;&lt;include file="struts-pay.xml"&gt;&lt;/include&gt; 八、Action接收请求参数 通过servlet获取 1234567891011public class LoginAction extends ActionSupport &#123; public String login() &#123; HttpServletRequest request = ServletActionContext.getRequest(); String username = request.getParameter("username"); String password = request.getParameter("password"); System.out.println(username); System.out.println(password); return NONE; &#125;&#125; 通过Action属性的setter方法注入 在访问action之前，拦截器先获取action，判断Action类是否有password和username属性，如果有就调用对应的setter方法为属性注入值。 123456789101112131415161718192021public class LoginAction extends ActionSupport &#123; private String password; private String username; public void setPassword(String password) &#123; System.out.println("set password"); this.password = password; &#125; public void setUsername(String username) &#123; System.out.println("set username"); this.username = username; &#125; public String login() &#123; System.out.println(username); System.out.println(password); return NONE; &#125;&#125; 通过Action属性的模型注入 其实也就是不分别注入username、password，Action类提供的是User成员变量，而User有username和password这两个成员变量。还是一样的过程，拦截器首先判断Action类是否有user这个属性，如果有就调用setUser方法注入参数。 提交的表单：注意name的值是user.username、user.password 12345&lt;form action="$&#123;pageContext.request.contextPath&#125;/login.do"&gt; username:&lt;input type="text" name="user.username"&gt; password:&lt;input type="password" name="user.password"&gt; &lt;input type="submit" value="登录"&gt;&lt;/form&gt; LoginAction：提供setUser、getUser方法 123456789101112131415161718public class LoginAction extends ActionSupport &#123; private User user; public void setUser(User user) &#123; System.out.println("set user"); this.user = user; &#125; public User getUser() &#123; System.out.println("get user"); return this.user; &#125; public String login() &#123; System.out.println(user); return NONE; &#125;&#125; 根据输出结果：getUser方法执行了2次，setter方法执行了1次，过程是：tomcat服务器创建Action实例，得到Action的具体信息，成员变量User、成员方法setter、getter，然后tomcat执行拦截器的内容，也就是判断是否有user这个属性，那么就调用setUser注入参数。过程如下：1. 首先调用getUser发现user为null；2. new 一个Use；3. 调用setUser设置user为new出来的user；3. 设置password；4. getUser，获取user去设置username Action的模型驱动封装参数 这个工作也是一个拦截器做了，这个拦截器叫模型驱动拦截器 com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor，它不会创建模型，因此Action提供的模型属性要自己new出来赋值。 Action实现一个 ModelDriven&lt;User&gt;接口，覆盖重写 getModel方法； Action提供一个模型属性，并且要赋值； 这种方法，表单的name就不用写user. Action: 12345678910111213public class LoginAction extends ActionSupport implements ModelDriven&lt;User&gt; &#123; private User user = new User();// user 要赋值！！ public String login() &#123; System.out.println(user); return NONE; &#125; @Override public User getModel() &#123; return user; &#125;&#125; 表单： 12345&lt;form action="$&#123;pageContext.request.contextPath&#125;/login.do"&gt; username:&lt;input type="text" name="username"&gt; password:&lt;input type="password" name="password"&gt; &lt;input type="submit" value="登录"&gt;&lt;/form&gt;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lunix基础]]></title>
    <url>%2F2019%2F05%2F28%2FLunix%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、linux的应用领域 基于linux的企业服务器：很多公司使用Linux作为服务端系统 嵌入式应用：安卓、智能家居、银行系统等 Linux在电影娱乐业的应用 二、常用命令命令基本格式：命令 [-选项] [参数]，例如：ls -la /usr 当有多个选项，可以写在一起 1. 目录、文件处理命令 ls：-l（long，显示详细信息）；-h（human，大小按kb、MB显示）；-a（显示隐藏文件）；-d（显示目录本身而非目录下文件的信息） mkdir：-p（递归创建，可以创建中间尚未存在的目录） pwd：打印当前目录的路径 rmdir：删除空目录；-r（） cp：cp 源文件 目标目录；-p（保存文件的属性，如修改时间等）；-r（复制目录）； mv：移动，移动目录不用加-r选项 rm：-r（删除目录）；-f（强制删除）； touch：创建文件 cat：查看文件；-n（查看的时候可以显示行号） more：查看文件，回车（翻页）；空格（换行）；q（退出） less：查看文件，可以向上翻页 head：查看文件 hean -n 20 filename（查看前20行） tail：和head类似，查看文件末尾 2. 更改文件权限 chmod：读r、写w、执行x三种权限用数字4、2、1表示，如 chmod 777 filename，表示所有用户拥有所有权限 权限对于文件和目录的含义不同：对于文件来说写w是修改文件，对于目录来说写w是在目录里创建删除目录（文件） chown：改变文件的所有者。chown 用户 文件或者目录（将文件的所有这改为新的所有者） chgrp：改变文件的所属组。chown 用户组 文件或者目录； umask：查看默认的创建文件、目录的权限 3. 文件搜索命令 find：find [搜索范围] [匹配条件] -name：匹配条件为文件名，*匹配任意字符串，？匹配任意单个字符，find /etc -name init -iname：不区分大小写的文件名 -size：+n（文件大小大于），-n（文件大小小于），=n（文件大小等于） -amin：匹配条件为访问时间，在/etc目录下查找5分钟内被访问过的文件 find /etc -amin -5 -mmin：匹配条件为修改时间，在/etc目录下查找30分钟内被修改过的文件 `find /etc -mmin -30 -type：匹配条件为文件类型，f表示文件，d表示目录 -a：当有多个查询条件时，使用-a连接，表示and -o：当有多个查询条件时，使用-o连接，表示or locate：类似于everything -i：不区分大小写 updatdb：更新文件资料库 grep：在文件内容中查找 sudo grep mysql /root/install.log -v：排除包含指定字符的行，如排除以#开始的行（也就是注释行）grep -v ^# mysql /root/install.log man：命令的帮助信息 man ls：查看ls的帮助信息 4.关机重启命令 shutdown：-r(重启)、-h(重启)、-c(取消前一个关机重启命令) #### 5. 打包压缩命令 打包压缩为.tar.gz tar -zcvf 打包压缩后的文件名 要打包压缩的文件 tar -zcvf xxx1.tar.gz a.txt b.python c.cpp dir1 dir2 tar -zcvf /usr/* 解压缩，-C 加解压后文件的位置 tar -xvf 压缩包 tar -xvf xxx.tar.gz(解压缩后放在当前目录) tar -xvf xxx.tar.gz -C ~/Desktop(解压缩后放在Desktop) zip压缩解压缩 压缩：zip -r xxx.zip ./*，将当前录下所有文件包括目录压缩为xxx.zip 解压缩：unzip -o -d ~/Desktop/dir xxx.zip，将xxx.zip解压到桌面下的dir目录，并且重复了（-o）也不提示就覆盖 5. vim常用操作、技巧 常用操作 插入命令： 命令 插入位置 i 在光标所在字符前插入 I 在光标所在行首插入 o 在光标下一行插入新行 O 在光标下一行插入新行 a 在光标所在字符后插入 A 在光标所在行尾插入 定位命令： 命令 作用 ：set nu 设置行号 ：set nonu 取消行号 x 删除光标所在处字符 nx 删除光标所在处后n个字符 dd 删除光标所在行 ndd 删除n行 D 删除光标所在处到行尾内容 复制剪切命令： 命令 作用 yy 复制当前行 nyy 复制当前行以下n行 dd 剪切当前行 ndd 剪切当前行以下n行 p、P 粘贴在当前行上、或者行下 取消和替换： 命令 作用 u 取消上一步操作 R 从光标所在处开始替换，知道按esc r 替换光标所在字符 查找： 命令 作用 /string 搜索指定字符串，如果要忽略大小写先输入命令 :set ic 退出和保存： 命令 作用 :w 保存修改 :w new_filename 另存为新文件 :wq 保存修改并退出 :q! 不保存修改退出 ZZ 快捷键，保存修改并退出]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis]]></title>
    <url>%2F2019%2F05%2F28%2FRedis%2F</url>
    <content type="text"><![CDATA[一、概念Redis是一款高性能的NOSQL系列（NoSQL = Not Only SQL ）的数据库 1.1.什么是NOSQL​ NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。​ 随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 ​ 1.1.1. NOSQL和关系型数据库比较​ 优点：​ 1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。​ 2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。​ 3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。​ 4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 ​ 缺点：​ 1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。​ 2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。​ 3）不提供关系型数据库对事务的处理。 ​ 1.1.2. 非关系型数据库的优势： ​ 1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。​ 2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。 ​ 1.1.3. 关系型数据库的优势：​ 1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。​ 2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。 ​ 1.1.4. 总结​ 关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，​ 让NoSQL数据库对关系型数据库的不足进行弥补。​ 一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据 1.2.主流的NOSQL产品​ • 键值(Key-Value)存储数据库​ 相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB​ 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。​ 数据模型： 一系列键值对​ 优势： 快速查询​ 劣势： 存储的数据缺少结构化​ • 列存储数据库​ 相关产品：Cassandra, HBase, Riak​ 典型应用：分布式的文件系统​ 数据模型：以列簇式存储，将同一列数据存在一起​ 优势：查找速度快，可扩展性强，更容易进行分布式扩展​ 劣势：功能相对局限​ • 文档型数据库​ 相关产品：CouchDB、MongoDB​ 典型应用：Web应用（与Key-Value类似，Value是结构化的）​ 数据模型： 一系列键值对​ 优势：数据结构要求不严格​ 劣势： 查询性能不高，而且缺乏统一的查询语法​ • 图形(Graph)数据库​ 相关数据库：Neo4J、InfoGrid、Infinite Graph​ 典型应用：社交网络​ 数据模型：图结构​ 优势：利用图结构相关算法。​ 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。 1.3 什么是Redis​ Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：​ 1) 字符串类型 string​ 2) 哈希类型 hash​ 3) 列表类型 list​ 4) 集合类型 set​ 5) 有序集合类型 sortedset​ 1.3.1 redis的应用场景​ • 缓存（数据查询、短连接、新闻内容、商品内容等等）​ • 聊天室的在线好友列表​ • 任务队列。（秒杀、抢购、12306等等）​ • 应用排行榜​ • 网站访问统计​ • 数据过期处理（可以精确到毫秒​ • 分布式集群架构中的session分离 二、命令操作1. Redis的数据结构Redis存储的是键值对，key都是字符串，value可以有5种不同的类型数据： 字符串 string 哈希类型 hash：map格式，可以存储键值对 列表类型 list：linkedlist格式，元素可以重复 集合类型 set 元素不可以重复 有序集合类型 sortedset 元素可以重复而且有序 2. Redis命令操作 字符串string 存储：set key value 获取：get key 删除：del key 哈希类型 hash 存储：hset key field value 获取： hget key field：获取指定的field对应的值 hgetall key：获取所有的field和value 删除：hdel key field 1234hset myhash username Tomhset myhash age 18hget myhash age -- 18 列表类型 list：可以添加一个元素到列表的头部（左）或者尾部（右） 存储： lpush key value：将元素加入列表左边 rpush key value：将元素加入列表右边 获取： lrange key start end：范围获取 删除： lpop：删除最左边元素，并返回该元素 rpop：删除最右边元素，并返回该元素 12345lpush mylist alpush mylist blpush mylist c -- a-&gt;b-&gt;clrange mylist 0 -1 -- 获取mylist所有的元素 集合类型 set 存储：sadd key value 获取：smembers key：获取集合中所有的元素 删除：srem key value：删除集合中某个元素 有序集合类型 sortedset 存储：zadd key score value 获取：zrange key start end（withscores） 删除：zrem key value 1234567891011 127.0.0.1:6379&gt;zadd sorted 10 aaa(integer) 1127.0.0.1:6379&gt; zadd sorted 30 bbb(integer) 1127.0.0.1:6379&gt; zadd sorted 20 ccc(integer) 1127.0.0.1:6379&gt; zrange sorted 0 -1// 按照分数（score）排序1) &quot;aaa&quot;2) &quot;ccc&quot;3) &quot;bbb&quot; 常用的通用命令： keys *：查询所有的键 type key：获取键对应的value的类型 del key：删除指定的key以及该key对应的value 三、Redis持久化Redis是一个基于内存的数据库，因此当Redis服务器重启会导致数据丢失，可以将Redis数据库的数据存储到硬盘。 1. Redis持久化机制 RDB: 默认方式，不需要进行配置，默认使用的机制，在一定的时间间隔内，检测key的变化情况，然后持久化数据 编辑配置文件：redis.windows.conf 1234567# after 900 sec (15 min) if at least 1 key changed# after 300 sec (5 min) if at least 10 keys changed# after 60 sec if at least 10000 keys changedsave 900 1save 300 10save 60 10000 重新启动Redis服务器，并且指定配置文件:$ redis-server.exe redis.windows.conf AOF: 记录日志的方式，可以记录每一条操作的命令，操作命令后就持久化数据（这样的效果和mysql类似了） 编辑配置文件：redis.windows.conf 12345678# 开启aof模式appendonly no --&gt; appendonly yes# aof模式下的三种持久化方式# appendfsync always # 总是，每一条操作都持久化appendfsync everysec # 每间隔1s进行一次持久化# appendfsync no # 不进行持久化 四、Java客户端Jedis Jedis是一款java操作Redis数据库的工具，类似于JDBC 使用步骤： 下载、导入jar包 使用 使用Demo 12345678910111213141516@Testpublic void test2() &#123; // 获取连接, 如果使用的是空参数的构造，那么默认就是localhost和6379 Jedis jedis = new Jedis("localhost", 6379); // 操作 jedis.set("username", "David"); String username = jedis.get("username"); System.out.println(username);// David // 可以使用方法setex来存储指定的过期时间的key value jedis.setex("activeCode", 20, "didi");// 20秒后键activeCode、值didi就被自动删除 // 关闭连接 jedis.close();&#125; Jedis连接池 12345678910111213141516171819@Testpublic void test5() &#123; // 创建一个配置对象 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(50);// 最大的允许连接数量 config.setMaxIdle(10);// 最大的空闲连接数 // 创建一个JedisPool连接池对象 JedisPool jedisPool = new JedisPool(config, "localhost", 6379); // 获取连接 Jedis jedis = jedisPool.getResource(); // 使用 jedis.set("username", "Tom"); // 归还连接给连接池 jedis.close();&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>
